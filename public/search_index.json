[
["index.html", "Aprender R: iniciación y perfeccionamiento 1 Preámbulo", " Aprender R: iniciación y perfeccionamiento François Rebaudo 2018-08-28 1 Preámbulo Este libro está incompleto por el momento y está leyendo su versión preliminar. Si tiene algún comentario, sugerencia o si identifica errores, no dude en enviarme un correo electrónico (francois.rebaudo@ird.fr), o si está familiarizado con GitHub en el sitio web del proyecto (https://github.com/frareb/myRBook_SP). Últimas modificaciones: 24/08/2018 Capítulo sobre las funciones (3/3) 27/07/2018 Capítulo sobre las funciones (2/3) 25/07/2018 Capítulo sobre las funciones (1/3) 17/07/2018 edición y corrección del español (Susi L.) tercera parte del capítulo Contenedores de datos: El contenedor data.frame cuarta parte del capítulo Contenedores de datos: El contenedor matrix quinta parte del capítulo Contenedores de datos: El contenedor array 16/07/2018 edición y corrección del español (Estefanía Q.) 12/07/2018 segunda parte del capítulo Contenedores de datos: El contenedor list 06/07/2018 edición y corrección del español (Camila B.) primera parte del capítulo Contenedores de datos: El contenedor vector 04/07/2018 tabla de contenidos con los próximos capítulos error de tipografía en Elegir un entorno de desarrollo 02/07/2018 tres capítulos en línea (primeros pasos, elegir un entorno de desarrollo, tipos de datos) "],
["remerciements.html", " 2 Agradecimientos", " 2 Agradecimientos Agradezco a todos los colaboradores que ayudaron a mejorar este libro con sus consejos, sugerencias de cambios y correcciones (en orden alfabético): ## Colaboradores : Camila Benavides Frias (Bolivia) Susi Loza Herrera (Bolivia) Estefania Quenta Herrera (Bolivia) Las versiones de gitbook, html y epub de este libro usan los iconos de fuente abierta de Font Awesome (https://fontawesome.com). La versión en PDF utiliza los iconos del proyecto Tango disponibles en openclipart (https://openclipart.org/). Este libro fue escrito con el paquete R bookdown (https://bookdown.org/). El código fuente está disponible en GitHub (https://github.com/frareb/myRBook_SP). La compilación usa Travis CI (https://travis-ci.org). La versión en línea se aloja y actualiza a través de Netlify (http://myrbooksp.netlify.com/). "],
["licence.html", " 3 Licencia", " 3 Licencia Licencia Reconocimiento-NoComercial-SinObraDerivada 3.0 España (CC BY-NC-ND 3.0 ES ; https://creativecommons.org/licenses/by-nc-nd/3.0/es/) Esto es un resumen inteligible para humanos (y no un sustituto) de la licencia. Usted es libre de: Compartir — copiar y redistribuir el material en cualquier medio o formato. El licenciador no puede revocar estas libertades mientras cumpla con los términos de la licencia. Bajo las condiciones siguientes: Reconocimiento — Debe reconocer adecuadamente la autoría, proporcionar un enlace a la licencia e indicar si se han realizado cambios&lt;. Puede hacerlo de cualquier manera razonable, pero no de una manera que sugiera que tiene el apoyo del licenciador o lo recibe por el uso que hace. NoComercial — No puede utilizar el material para una finalidad comercial. SinObraDerivada — Si remezcla, transforma o crea a partir del material, no puede difundir el material modificado. No hay restricciones adicionales — No puede aplicar términos legales o medidas tecnológicas que legalmente restrinjan realizar aquello que la licencia permite. Avisos: No tiene que cumplir con la licencia para aquellos elementos del material en el dominio público o cuando su utilización esté permitida por la aplicación de una excepción o un límite. No se dan garantías. La licencia puede no ofrecer todos los permisos necesarios para la utilización prevista. Por ejemplo, otros derechos como los de publicidad, privacidad, o los derechos morales pueden limitar el uso del material. "],
["intro.html", " 4 Introducción 4.1 ¿Por qué aprender R? 4.2 Este libro 4.3 Lectura adicional en español", " 4 Introducción 4.1 ¿Por qué aprender R? 4.2 Este libro 4.3 Lectura adicional en español R para Principiantes, Emmanuel Paradis (https://cran.r-project.org/doc/contrib/rdebuts_es.pdf) xxx "],
["premiersPas.html", " 5 Primeros pasos 5.1 Instalar R 5.2 R como calculadora 5.3 El concepto de objeto 5.4 Los scripts 5.5 Conclusión", " 5 Primeros pasos 5.1 Instalar R El programa para instalar el software R se puede descargar desde el sitio web de R: https://www.r-project.org/. En el sitio web de R, primero es necesario elegir un espejo CRAN (servidor desde el cual se debe descargar R, y desde el más cercano a su ubicación geográfica), luego descargue el archivo base. Los usuarios de Linux pueden preferir un sudo apt-get install r-base. El software R se puede descargar de muchos servidores CRAN (Comprehensive R Archive Network) de todo el mundo. Estos servidores se llaman espejos. La elección del espejo es manual. La información adicional como esta nota siempre estará representada con este pictograma información. 5.2 R como calculadora Una vez que se inicia el programa, aparece una ventana cuya apariencia puede variar dependiendo de su sistema operativo (Figura 5.1). Esta ventana se llama consola. Figure 5.1: Captura de pantalla de la consola R en Windows. La consola corresponde a la interfaz donde se interpretará el código, es decir, donde el código será transformado en lenguaje de máquina, ejecutado por la computadora y retransmitido en forma legible por humanos. Esto es análogo a lo que sucede en una calculadora (Figura 5.2). Así es como se usará R más adelante en esta sección. A lo largo de este libro, los ejemplos del código R aparecerán sobre un fondo gris. Se pueden copiar y pegar directamente en la consola, aunque es mejor reproducir los ejemplos escribiéndolos en la consola (o más adelante en los scripts) para una mejor comprensión del manejo del programa R. El resultado de lo que se envía en la consola también aparecerá en un fondo gris con ## delante del código para hacer la distinción entre el código y el resultado del código. Figure 5.2: Captura de pantalla de la consola R al lado de la calculadora de Windows. 5.2.1 Los operadores aritméticos 5 + 5 ## [1] 10 Si escribimos 5 + 5 en la consola y luego Enter, el resultado aparece precedido por el número [1] entre corchetes. Este número corresponde al número del resultado (en nuestro caso, solo hay un resultado, volveremos a este aspecto más adelante). También podemos observar en este ejemplo el uso de espacios antes y después del signo +. Estos espacios no son necesarios, pero permiten que el código sea más legible para los humanos (es decir, más agradable de leer tanto para nosotros como para las personas con las que queremos compartir nuestro código). Los operadores aritméticos disponibles en R se resumen en la tabla 5.1. Table 5.1: Operadores aritméticos. Label Operador adición + resta - multiplicación * división / potencia ^ módulo %% cociente decimal %/% Clásicamente, las multiplicaciones y divisiones tienen prioridad sobre las adiciones y sustracciones. Si es necesario, podemos usar paréntesis. 5 + 5 * 2 ## [1] 15 (5 + 5) * 2 ## [1] 20 (5 + 5) * (2 + 2) ## [1] 40 (5 + 5) * ((2 + 2) / 3)^2 ## [1] 17.77778 El operador módulo corresponde al resto de la división euclidiana. Se usa en ciencias de la computación, por ejemplo, para saber si un número es par o impar (un número módulo 2 devolverá 1 si es impar y 0 si es par). 451 %% 2 ## [1] 1 288 %% 2 ## [1] 0 (5 + 5 * 2) %% 2 ## [1] 1 ((5 + 5) * 2) %% 2 ## [1] 0 R también incorpora algunas constantes que incluyen pi. Además, el signo infinito está representado por Inf. pi ## [1] 3.141593 pi * 5^2 ## [1] 78.53982 1/0 ## [1] Inf el estilo del código es importante porque el código está destinado a ser leído por nosotros y por otras personas. Para tener un estilo legible, se recomienda colocar espacios antes y después de los operadores aritméticos, excepto “*“,”/&quot; y “^”, aunque a veces es útil agregarlos como es el caso en nuestro ejemplos. La información sobre el estilo siempre estará representada con este pictograma para que sea fácilmente identificable. 5.2.2 Los operadores comparativos Sin embargo, R es mucho más que una simple calculadora porque permite otro tipo de operadores: operadores de comparación, para comparar los valores (Table 5.2). Table 5.2: Operadores de comparación. Label Operador más pequeño que &lt; mayor que &gt; más pequeño o igual a &lt;= más grande o igual a &gt;= igual a == diferente de != Por ejemplo, si queremos saber si un numero es más grande que otro, podemos escribir: 5 &gt; 3 ## [1] TRUE R devuelve TRUE si la comparación es verdadera y FALSE si la comparación es falsa. 5 &gt; 3 ## [1] TRUE 2 &lt; 1.5 ## [1] FALSE 2 &lt;= 2 ## [1] TRUE 3.2 &gt;= 1.5 ## [1] TRUE Podemos combinar operadores aritméticos con operadores de comparación. (5 + 8) &gt; (3 * 45/2) ## [1] FALSE En la comparación (5 + 8) &gt; (3 * 45/2) no se necesitan paréntesis, pero permiten que el código sea más fácil de leer. Un operador de comparación particular es igual a. Veremos en la siguiente sección que el signo = está reservado para otro uso: permite asignar un valor a un objeto. El operador de comparación igual a debe ser diferente, por eso R usa ==. 42 == 53 ## [1] FALSE 58 == 58 ## [1] TRUE Otro operador particular es diferente de. Se usa con un signo de admiración seguido de igual, !=. Este operador permite obtener la respuesta opuesta a ==. 42 == 53 ## [1] FALSE 42 != 53 ## [1] TRUE (3 + 2) != 5 ## [1] FALSE 10/2 == 5 ## [1] TRUE R usa TRUE y FALSE, que también son valores que se pueden probar con operadores de comparación. Pero R también asigna un valor a TRUE y FALSE: TRUE == TRUE ## [1] TRUE TRUE &gt; FALSE ## [1] TRUE 1 == TRUE ## [1] TRUE 0 == FALSE ## [1] TRUE TRUE + 1 ## [1] 2 FALSE + 1 ## [1] 1 (FALSE + 1) == TRUE ## [1] TRUE El valor de TRUE es 1 y el valor de FALSE es 0. Veremos más adelante cómo usar esta información en los próximos capítulos. R es también un lenguaje relativamente permisivo, significa que admite cierta flexibilidad en la forma de escribir el código. Debatir sobre la idoneidad de esta flexibilidad está fuera del alcance de este libro, pero podemos encontrar en el código R en Internet o en otras obras el atajo T para TRUE y F for FALSE. T == TRUE ## [1] TRUE F == FALSE ## [1] TRUE T == 1 ## [1] TRUE F == 0 ## [1] TRUE (F + 1) == TRUE ## [1] TRUE Aunque esta forma de referirse a TRUE y FALSE por T y F está bastante extendida, en este libro siempre usaremos TRUE y FALSE para que el código sea más fácil de leer. Como mencionado anterioramente, el objetivo de un código no solo es ser funcional sino también fácil de leer y volver a leer. 5.2.3 Los operadores lógicos Hay un último tipo de operador, los operadores lógicos. Estos son útiles para combinar operadores de comparación (Table 5.3). Table 5.3: Operadores lógicos. Label Operador no es ! y &amp; o | o exclusivo xor() !TRUE ## [1] FALSE !FALSE ## [1] TRUE ((3 + 2) == 5) &amp; ((3 + 3) == 5) ## [1] FALSE ((3 + 2) == 5) &amp; ((3 + 3) == 6) ## [1] TRUE (3 &lt; 5) &amp; (5 &lt; 5) ## [1] FALSE (3 &lt; 5) &amp; (5 &lt;= 5) ## [1] TRUE El operador lógico xor() es o exclusivo. Es decir, uno de los dos argumentos de la función xor() debe ser verdadero, pero no ambos. Más adelante volveremos a las funciones y sus argumentos, pero recuerde que identificamos una función por sus paréntesis que contienen argumentos separados por comas. xor((3 + 2) == 5, (3 + 3) == 6) ## [1] FALSE xor((3 + 2) == 5, (3 + 2) == 6) ## [1] TRUE xor((3 + 3) == 5, (3 + 2) == 6) ## [1] FALSE xor((3 + 3) == 5, (3 + 3) == 6) ## [1] TRUE Se recomienda que las comas , sean seguidas de un espacio para que el código sea más agradable de leer. 5.2.4 Ayuda a los operadores El archivo de ayuda en inglés sobre operadores aritméticos se puede obtener con el comando ?'+'. El de los operadores de comparación con el comando ?'==' y el de los operadores lógicos con el comando ?'&amp;'. 5.3 El concepto de objeto Un aspecto importante de la programación con R, pero también la programación en general es la noción de objeto. Como se indica en la página web de wikipedia (https://ia.wikipedia.org/wiki/Objecto_(informatica)), en ciencias de la computación, un objeto es un contenedor, es decir, algo que contendrá información. La información contenida en un objeto puede ser muy diversa, pero por el momento contendremos en un objeto el número 5. Para hacer esto (y para reutilizarlo más adelante), debemos darle un nombre a nuestro objeto. En R, los nombres de los objetos no deben contener caracteres especiales como ^ $ ? | + () [] {}, entre otros. No deben comenzar con un número ni contener espacios. El nombre del objeto debe ser representativo de lo que contiene, sin ser demasiado corto ni demasiado largo. Imagine que nuestro número 5 corresponde al número de repeticiones de un experimento. Nos gustaría darle un nombre que se refiera a numero y repeticiones, que podríamos reducir a nbr y rep, respectivamente (nbr para number en ingles). Hay varias posibilidades que son bastante comunes bajo R: la separación mediante guión bajo (underscore): nbr_rep la separación mediante el carácter punto: nbr.rep el uso de letras minúsculas: nbrrep el estilo lowerCamelCase que consiste en una primera palabra en minúscula y la primera letra de las siguientes palabras con una letra mayúscula: nbrRep el estilo UpperCamelCase donde cada palabra comienza con una letra mayúscula: NbrRep Todas estas formas de nombrar un objeto son equivalentes. En este libro usaremos el estilo lowerCamelCase. En general, debemos evitar los nombres que son demasiado largos, como miNumeroDeRepeticionesDeMiExperimento o demasiado cortos como nR, y los nombres que no permiten identificar los contenidos como miVariable o miNumero, asi que nombres como a o b. El objetivo es de tener una idea de lo que hay en cada objeto en base a su nombre. Hay diferentes maneras de definir un nombre para los objetos que crearemos con R. En este libro, utilizamos el estilo lowerCamelCase. Lo importante no es la elección del estilo, sino la consistencia en su elección. El objetivo es tener un código funcional, pero también un código que sea fácil y agradable de leer para nosotros y para los demás. Ahora que hemos elegido un nombre para nuestro objeto, debemos crearlo y hacer que R entienda que nuestro objeto debe contener el número 5. Hay tres maneras de crear un objeto bajo R: con &lt;- con = o con -&gt; nbrRep &lt;- 5 nbrRep = 5 5 -&gt; nbrRep En este libro siempre usaremos la forma &lt;- para coherencia y también porque es la forma más común. nbrRep &lt;- 5 Acabamos de crear un objeto nbrRep y establecerlo con el valor 5. Este objeto ahora está disponible en nuestro entorno de computación y puede ser utilizado. Algunos ejemplos : nbrRep + 2 ## [1] 7 nbrRep * 5 - 45/56 ## [1] 24.19643 pi * nbrRep^2 ## [1] 78.53982 El valor asociado con nuestro objeto nbrRep se puede modificar de la misma manera que cuando se creó: nbrRep &lt;- 5 nbrRep + 2 ## [1] 7 nbrRep &lt;- 10 nbrRep + 2 ## [1] 12 nbrRep &lt;- 5 * 2 + 7/3 nbrRep + 2 ## [1] 14.33333 El uso de objetos tiene sentido cuando tenemos operaciones complejas para realizar y hace que el código sea más agradable de leer y entender. (5 + 9^2 - 1/18) / (32 * 45/8 + 3) ## [1] 0.4696418 termino01 &lt;- 5 + 9^2 - 1/18 termino02 &lt;- 32 * 45/8 + 3 termino01 / termino02 ## [1] 0.4696418 5.4 Los scripts R es un lenguaje de programación denominado lenguaje de scripting. Esto se refiere al hecho de que la mayoría de los usuarios escribirán pequeñas piezas de código en lugar de programas completos. R se puede usar como una simple calculadora, y en este caso no será necesario mantener un historial de las operaciones que se han realizado. Pero si las operaciones a implementar son largas y complejas, puede ser necesario e interesante guardar lo que se ha hecho para poder continuar más adelante. El archivo en el que se almacenarán las operaciones es lo que comúnmente se llama el script. Un script, por lo tanto, es un archivo que contiene una sucesión de información comprensible por R y que es posible ejecutar. 5.4.1 Crear un script y documentarlo Para crear un nuevo script basta con abrir un documento vacío de texto, que será editado por un editor de texto como el bloc de notas en Windows o Mac OSX, o Gedit o incluso nano en Linux. Por convención, este archivo toma la extensión “.r” o “.R” (lo mas comun). Esta última convención se usará en este libro (“miArchivo.R”). Desde la interfaz gráfica de R, es posible crear un nuevo script en Mac OS y Windows a través de file, luego new script y save as. Al igual que el nombre de los objetos, el nombre del script es importante para que podamos identificar fácilmente su contenido. Por ejemplo, podríamos crear un archivo formRConceptsBase.R que contenga los objetos que acabamos de crear y los cálculos que hicimos. Pero incluso con nombres de objetos y archivos bien definidos, será difícil recordar el significado de este archivo sin la documentación que acompaña a este script. Para documentar un script utilizaremos comentarios. Los comentarios son elementos que R identificará como tales y no se ejecutarán. Para especificar a R que vamos a hacer un comentario, debemos usar el carácter octothorpe (corsé o numeral) #. Los comentarios se pueden insertar en una nueva línea o al final de la línea. # creación objeto número de repeticiones nbrRep &lt;- 5 # Comentario de fin de línea Todo lo que hay despues del simbolo numeral # no sera ejecutado. Significa que podriamos usar comentarios como ### o #comentario, aun que se recomienda hacer comentarios con un solo simbolo numeral seguido por un espacio y despues su comentario: # mi comentario. Los comentarios también se pueden usar para hacer que una línea ya no se ejecute. En este caso no queremos ejecutar la secunda linea: nbrRep &lt;- 5 # nbrRep + 5 Para volver a la documentación del script, se recomienda comenzar cada uno de nuestros scripts con una breve descripción de su contenido, luego cuando el script sea extenso, estructurarlo en diferentes partes para facilitar su lectura. # ------------------------------------------------------------ # Aquí hay un script para adquirir los conceptos básicos # con R # fecha de creación : 27/06/2018 # autor : François Rebaudo # ------------------------------------------------------------ # [1] creación del objeto número de repeticiones # ------------------------------------------------------------ nbrRep &lt;- 5 # [2] cálculos simples # ------------------------------------------------------------ pi * nbrRep^2 ## [1] 78.53982 Para ir más allá en el estilo del código, una guía completa de recomendaciones está disponible en línea en el sitio web tidyverse (en ingles ; http://style.tidyverse.org/). 5.4.2 Ejecutar un script Como tenemos un script, no trabajamos directamente en la consola. Pero solo la consola puede entender el código R y devolvernos los resultados que queremos obtener. Por ahora, la técnica más simple es copiar y pegar las líneas que queremos ejecutar desde nuestro script hasta la consola. A partir de ahora, ya no utilizaremos editores de texto como bloc de notas, sino editores especializados para la creación de scripts R. Sera es el objetivo del siguiente capítulo. 5.5 Conclusión Felicitaciones, hemos llegado al final de este primer capítulo sobre la base de R. Sabemos: Instalar R Usar R como una calculadora Crear objetos y utilisarlos para los calculos aritméticos, comparativos y logicos Elejir nombres pertinentes para los objetos Crear un nuevo script Elejir un nombre pertinente para el archivo del script Ejecutar el codigo de un script Documentar los scripts con comentarios Usar un estilo de código para que sea agradable de leer y facil de entender "],
["IDE.html", " 6 Elegir un entorno de desarrollo 6.1 Editores de texto y entorno de desarrollo 6.2 RStudio 6.3 Notepad++ avec Npp2R 6.4 Geany 6.5 Otras soluciones 6.6 Conclusión", " 6 Elegir un entorno de desarrollo 6.1 Editores de texto y entorno de desarrollo Hay muchos editores de texto, el capítulo anterior permitió introducir algunos de los más simples como el bloc de notas de Windows. Sin embargo, los límites de estos editores han hecho tediosa la tarea de escribir un script. De hecho, incluso estructurando su script con comentarios, sigue siendo difícil entenderlo. Aquí es donde entran los editores de texto especializados para facilitar la escritura y la lectura de scripts. El editor de texto para R más común es Rstudio, pero hay muchos más. Hacer una lista exhaustiva de todas las soluciones disponibles está más allá del alcance de este libro, por lo que nos centraremos en las tres soluciones que utilizo a diario: Notepad++, Rstudio y Geany. No necesita instalar más de un editor de texto. Aquí recomendamos RStudio para principiantes a R. 6.2 RStudio Figure 6.1: Logo RStudio. 6.2.1 Instalar RStudio El programa para instalar el software RStudio se encuentra en la parte Products del sitio web de RStudio (https://www.rstudio.com/). Instalaremos RStudio para uso local (en nuestra computadora), por lo que la versión que nos interesa es Desktop. Usaremos la versión Open Source que es gratuita. Luego, seleccionamos la versión que corresponde a nuestro sistema operativo (Windows, Mac OS, Linux), descargamos el archivo correspondiente y lo ejecutamos para comenzar la instalación. Podemos mantener las opciones predeterminadas durante la instalación. 6.2.2 Un script con RStudio Podemos abrir RStudio. En la primera apertura, la interfaz se divide en dos con la consola R a la izquierda que vimos en el capítulo anterior (Figura 6.2). Para abrir un nuevo script, vamos al menú Archivo (o File), Nuevo archivo (o New File), R script. Por defecto, este archivo tiene el nombre Untitled1. Hemos visto en el capítulo anterior la importancia de dar un nombre pertinente a nuestros scripts, por lo que lo cambiaremos de nombre a selecEnvDev.R, en el menú Archivo (o File), con la opción Guardar como … (o Save As…). Podemos notar que el lado izquierdo de RStudio ahora está dividido en dos, con la consola en la parte inferior de la pantalla y el script en la parte superior. Figure 6.2: Captura de pantalla de RStudio en Windows: pantalla por defecto. Luego podemos comenzar a escribir nuestro script con los comentarios que describan lo que vamos a encontrar allí, y agregar un cálculo simple. Una vez que hayamos copiado o escrito un código, podemos guardar nuestro script con el comando CTRL + S o yendo a Archivo (o File, luego Guardar (o Save). # ------------------------------------------------------------ # Un script para seleccionar su entorno de desarrollo # fecha de creación : 27/06/2018 # autor : François Rebaudo # ------------------------------------------------------------ # [1] cálculos simples # ------------------------------------------------------------ nbrRep &lt;- 5 pi * nbrRep^2 ## [1] 78.53982 Para ejecutar nuestro script, simplemente seleccionamos las líneas que deseamos ejecutar y usamos la combinación de teclas CTRL + ENTER. El resultado aparece en la consola (Figura 6.3). Figure 6.3: Captura de pantalla de RStudio en Windows: ejecutar nuestro script con CTRL + ENTER. Podemos ver que, de forma predeterminada, en la parte del script, los comentarios aparecen en verde, los números en azul y el resto del código en negro. En la parte de la consola, lo que se ejecutó aparece en azul y los resultados de la ejecución en negro. También podemos observar que en la parte del código cada línea tiene un número correspondiente al número de línea a la izquierda sobre un fondo gris. Este es el resaltado de preferencias de sintaxis predeterminado con RStudio. Estas preferencias de sintaxis pueden modificarse yendo al menú Herramientas (o Tools), Opciones globales … (o Global Options…), Aspecto (o Appearance), y luego seleccionando otro tema del Editor de tema: (o Editor theme:). Elegiremos el tema Cobalt, luego OK (Figura 6.4). Figure 6.4: Captura de pantalla de RStudio en Windows: cambiar preferencias de sintaxis. Sabemos cómo crear un nuevo script, guardarlo, ejecutar su contenido y cambiar la apariencia de RStudio. Veremos los muchos otros beneficios de RStudio a lo largo de este libro, ya que es el entorno de desarrollo que se utilizará. Sin embargo, seremos especialmente cuidadosos de que todos los scripts desarrollados a lo largo de este libro se ejecuten de la misma manera, independientemente del entorno de desarrollo utilizado. 6.3 Notepad++ avec Npp2R Figure 6.5: Logo Notepad++ 6.3.1 Instalar Notepad++ (solamente para Windows) El programa para instalar Notepad ++ se puede encontrar en la pestaña Downloads (https://notepad-plus-plus.org/download/). Podemos elegir entre la versión de 32-bit y la de 64-bit (64-bit si no sabe qué versión elegir). Notepad++ es suficiente para escribir un script, pero es aún más poderoso con Notepad++ to R (Npp2R) que permite ejecutar automáticamente nuestros scripts en una consola localmente en nuestra computadora o remotamente en un servidor. 6.3.2 Instalar Npp2R El programa para instalar Npp2R está alojado en el sitio de Sourceforge (https://sourceforge.net/projects/npptor/). Npp2R debe instalarse después de Notepad++. 6.3.3 Un script con Notepad++ Al abrir por primera vez, Notepad++ muestra un archivo vacío new 1 (Figura 6.6). Figure 6.6: Captura de pantalla de Notepad++ en Windows: pantalla por defecto. Como ya hemos creado un script para probarlo con RStudio, lo abriremos de nuevo con Notepad++. En Archivo, seleccionamos Abrir … luego elijemos el script selecEnvDev.R creado previamente. Una vez que el script está abierto, vamos a Idioma, luego R, y de nuevo R. Aparece el resaltado de sintaxis (Figura 6.7). Figure 6.7: Captura de pantalla de Notepad++ en Windows: ejecutar nuestro script con F8. La ejecución del script solo se puede realizar si se está ejecutando Npp2R. Para hacerlo, es necesario ejecutar el programa Npp2R desde el prompt de Windows. Un icono debe aparecer en la parte inferior de su pantalla demostrando que Npp2R está prendido. La ejecución automática del código de Notepad++ se realiza seleccionando el código para ejecutar y luego usando el comando F8. Si el comando no funciona, puede ser necesario reiniciar la computadora. Si el comando funciona, se abrirá una nueva ventana con una consola que ejecuta las líneas deseadas (Figura 6.8). Figure 6.8: Captura de pantalla de Notepad++ en Windows: la consola con F8. Al igual que con RStudio, el resaltado de sintaxis se puede cambiar desde el menú Configuración, y se puede seleccionar un nuevo tema (por ejemplo, Solarized en la Figura 6.9) Figure 6.9: Captura de pantalla de Notepad++ en Windows con el tema Solarized. Comparado con otros editores de texto, Notepad++ tiene la ventaja de ser muy liviano, rapido y ofrece una amplia gama de opciones para personalizar la escritura de códigos. 6.4 Geany Figure 6.10: Logo Geany 6.4.1 Instalar Geany (para Linux, Mac OSX y Windows) El programa para instalar Geany se puede encontrar en la pestaña Downloads en el menú de la izquierda Releases de la página web (https://www.geany.org/). Luego solo descargamos el ejecutable para Windows o el dmg para Mac OSX. Los usuarios de Linux preferirán un sudo apt-get install geany. 6.4.2 Un script con Geany Al abrir por primera vez, como para RStudio y Notepad++, se crea un archivo vacío (Figura 6.11). Figure 6.11: Captura de pantalla de Geany en Windows: pantalla por defecto. Podemos abrir nuestro script con Archivo, Abrir (Figura 6.12). Figure 6.12: Captura de pantalla de Geany en Windows: abrir un script. Para ejecutar nuestro script, la versión de Geany para Windows no tiene un terminal incorporado, lo que hace que su uso sea limitado bajo este sistema operativo. La ejecución de un script se puede hacer abriendo R en una ventana separada y copiando y pegando las líneas que se ejecutarán. En Linux y Mac OSX, podemos abrir R en el terminal en la parte inferior de la ventana de Geany con el comando R. Podemos configurar Geany para una combinación de teclas para ejecutar el código seleccionado (por ejemplo CTRL + R). Para esto hay que permitir el envío de selección al terminal (send_selection_unsafe = true) in archivo geany.conf y elegir el comando para enviar al terminal (en Editar, Preferencias, Combinaciones). Para cambiar el tema de Geany, hay una colección de temas disponibles en GitHub (https://github.com/geany/geany-themes/). El tema se puede cambiar a través del menú Ver, cambiar Esquema del color … (un ejemplo con el tema Solarized Figura @ref(Fig: screenCapGeany03)). Figure 6.13: Captura de pantalla de Geany en Windows: cambiar esquema de color. 6.5 Otras soluciones Hay muchas otras soluciones, algunas especializadas para R como Tinn-R (https://sourceforge.net/projects/tinn-r/), y otras más generales para programación como Atom (https://atom.io/), Sublime Text (https://www.sublimetext.com/), Vim (https://www.vim.org/), Gedit (https://wiki.gnome.org/Apps/Gedit), GNU Emacs (https://www.gnu.org/software/emacs/), o Brackets (http://brackets.io/) y Eclipse (http://www.eclipse.org/). 6.6 Conclusión Felicitaciones, llegamos al final de este capítulo sobre el entorno de desarrollo para el uso de R. Hasta ahora sabemos: Instalar RStudio, Geany o Notepad++ Reconocer y elegir nuestro entorno de preferencia A partir de acá podremos concentrarnos en el lenguaje de programación R en un ambiente, facilitando el trabajo de lectura y de escritura del código. Esto ya es un gran paso para manejar R. "],
["dataType1.html", " 7 Tipos de datos 7.1 El tipo numeric 7.2 El tipo character 7.3 El tipo factor 7.4 El tipo logical 7.5 Acerca de NA 7.6 Conclusión", " 7 Tipos de datos Vimos anteriormente cómo crear un objeto. Un objeto es como una caja en la que almacenaremos información. Hasta ahora solo hemos almacenado números, pero en este capítulo veremos que es posible almacenar otra información y nos detendremos en los tipos más comunes. En este capítulo utilizaremos funciones sobre las cuales volveremos más adelante. 7.1 El tipo numeric El tipo numeric es lo que hemos hecho hasta ahora, almacenando números. Hay dos tipos principales de números en R: enteros (integer) y números decimales (double). Por defecto, R considera todos los números como números decimales y asigna el tipo double. Para verificar el tipo de datos utilizaremos la función typeof() que toma como argumento un objeto (o directamente la información que queremos probar). También podemos usar la función is.double() que devolverá TRUE si el número está en formato double y FALSE en caso contrario. La función genérica is.numeric() devolverá TRUE si el objeto está en formato numeric y FALSE en caso contrario. nbrRep &lt;- 5 typeof(nbrRep) ## [1] &quot;double&quot; typeof(5.32) ## [1] &quot;double&quot; is.numeric(5) ## [1] TRUE is.double(5) ## [1] TRUE Si queremos decirle a R que vamos a trabajar con un entero, entonces necesitamos convertir nuestro número decimal en un entero con la función as.integer(). También podemos usar la función is.integer() que devolverá TRUE si el número está en formato integer y FALSE en caso contrario. nbrRep &lt;- as.integer(5) typeof(nbrRep) ## [1] &quot;integer&quot; typeof(5.32) ## [1] &quot;double&quot; typeof(as.integer(5.32)) ## [1] &quot;integer&quot; as.integer(5.32) ## [1] 5 as.integer(5.99) ## [1] 5 is.numeric(nbrRep) ## [1] TRUE Vemos aquí que convertir un número como 5.99 a integer solo devolverá la parte entera, 5. is.integer(5) ## [1] FALSE is.numeric(5) ## [1] TRUE is.integer(as.integer(5)) ## [1] TRUE is.numeric(as.integer(5)) ## [1] TRUE La suma de un número entero integer y un número decimal double devuelve un número decimal. sumIntDou &lt;- as.integer(5) + 5.2 typeof(sumIntDou) ## [1] &quot;double&quot; sumIntInt &lt;- as.integer(5) + as.integer(5) typeof(sumIntInt) ## [1] &quot;integer&quot; Para resumir, el tipo numeric contiene dos subtipos, los tipos integer para enteros y el tipo double para los números decimales. Por defecto, R asigna el tipo double a los números. 7.2 El tipo character El tipo character es texto. De hecho, R permite trabajar con texto. Para especificar a R que la información contenida en un objeto está en formato de texto (o generalmente para todos los textos), usamos las comillas dobles (&quot;) o las comillas simples ('). myText &lt;- &quot;azerty&quot; myText2 &lt;- &#39;azerty&#39; myText3 &lt;- &#39;azerty uiop qsdfg hjklm&#39; typeof(myText3) ## [1] &quot;character&quot; Tanto las comillas dobles y simples son útiles en nuestro texto. También podemos escapar un carácter especial como comillas gracias al signo de barra invertida \\. myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; print(myText) ## [1] &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; myText2 &lt;- &#39;a &quot;zert&quot; y&#39; print(myText2) ## [1] &quot;a \\&quot;zert\\&quot; y&quot; myText3 &lt;- &#39;azerty uiop qsdfg hjklm&#39; print(myText3) ## [1] &quot;azerty uiop qsdfg hjklm&quot; myText4 &lt;- &quot;qwerty \\&quot; azerty &quot; print(myText4) ## [1] &quot;qwerty \\&quot; azerty &quot; myText5 &lt;- &quot;qwerty \\\\ azerty &quot; print(myText5) ## [1] &quot;qwerty \\\\ azerty &quot; De forma predeterminada, cuando creamos un objeto, su contenido no es devuelto por la consola. En Internet o en muchos libros podemos encontrar el nombre del objeto en una línea para devolver sus contenidos: myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; myText ## [1] &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; En este libro, no lo usaremos de esta manera y preferiremos el uso de la función print(), que permite mostrar en la consola el contenido de un objeto. El resultado es el mismo, pero el código es más fácil de leer y más explícito sobre lo que hace. myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; print(myText) ## [1] &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; nbrRep &lt;- 5 print(nbrRep) ## [1] 5 También podemos poner números en formato de texto, pero no debemos olvidar poner comillas para especificar el tipo character o usar la funciónas.character(). Una operación entre un texto y un número devuelve un error. Por ejemplo, si agregamos 10 a 5, R nos dice que un argumento de la función + no es un tipo numeric y que, por lo tanto, la operación no es posible. Tampoco podemos agregar texto a texto, pero veremos más adelante cómo concatenar dos cadenas de texto. myText &lt;- &quot;qwerty&quot; typeof(myText) ## [1] &quot;character&quot; myText2 &lt;- 5 typeof(myText2) ## [1] &quot;double&quot; myText3 &lt;- &quot;5&quot; typeof(myText3) ## [1] &quot;character&quot; myText2 + 10 ## [1] 15 as.character(5) ## [1] &quot;5&quot; # myText3 + 10 # Error in myText3 + 10 : non-numeric argument to binary operator # &quot;a&quot; + &quot;b&quot; # Error in &quot;a&quot; + &quot;b&quot; : non-numeric argument to binary operator Para resumir, el tipo character permite el ingreso de texto, podemos reconocerlo con comillas simples o dobles. 7.3 El tipo factor El tipo factor corresponde a los factores. Los factores son una elección dentro de una lista finita de posibilidades. Por ejemplo, los países son factores porque existe una lista finita de países en el mundo en un momento dado. Un factor puede definirse con la función factor() o transformarse utilizando la función as.factor(). Al igual que con otros tipos de datos, podemos usar la función is.factor() para verificar el tipo de datos. Para obtener una lista de todas las posibilidades, existe la función levels() (esta función tendrá más sentido cuando nos acerquemos a los tipos de contenedores de información). factor01 &lt;- factor(&quot;aaa&quot;) print(factor01) ## [1] aaa ## Levels: aaa typeof(factor01) ## [1] &quot;integer&quot; is.factor(factor01) ## [1] TRUE levels(factor01) ## [1] &quot;aaa&quot; Un factor se puede transformar en texto con la función as.character() pero también en número con as.numeric(). Al cambiar al tipo numeric, cada factor toma el valor de su posición en la lista de posibilidades. En nuestro caso, solo hay una posibilidad, por lo que la función as.numeric() devolverá 1: factor01 &lt;- factor(&quot;aaa&quot;) as.character(factor01) ## [1] &quot;aaa&quot; as.numeric(factor01) ## [1] 1 7.4 El tipo logical El tipo logical corresponde a los valores TRUE y FALSE (y NA) que ya hemos visto con los operadores de comparación. aLogic &lt;- TRUE print(aLogic) ## [1] TRUE typeof(aLogic) ## [1] &quot;logical&quot; is.logical(aLogic) ## [1] TRUE aLogic + 1 ## [1] 2 as.numeric(aLogic) ## [1] 1 as.character(aLogic) ## [1] &quot;TRUE&quot; 7.5 Acerca de NA El valor NA se puede usar para especificar que no hay datos o datos faltantes. Por defecto, NA es logical, pero se puede usar para texto o números. print(NA) ## [1] NA typeof(NA) ## [1] &quot;logical&quot; typeof(as.integer(NA)) ## [1] &quot;integer&quot; typeof(as.character(NA)) ## [1] &quot;character&quot; NA == TRUE ## [1] NA NA == FALSE ## [1] NA NA &gt; 1 ## [1] NA NA + 1 ## [1] NA 7.6 Conclusión Felicitaciones, hemos llegado al final de este capítulo sobre los tipos de datos. Ahora sabemos: Reconocer y hacer objetos en los principales tipos de datos Transformar tipos de datos de un tipo a otro Este capítulo es la base para el próximo capítulo sobre contenedores de datos. "],
["dataType2.html", " 8 Contenedores de datos 8.1 El contenedor vector 8.2 El contenedor list 8.3 El contenedor data.frame 8.4 El contenedor matrix 8.5 El contenedor array 8.6 Conclusión", " 8 Contenedores de datos Hasta ahora hemos creado objetos simples que contienen solo un valor. Sin embargo, pudimos ver que un objeto tenía atributos diferentes, como su valor, pero también el tipo de datos contenidos (e.g., numeric, character). Ahora vamos a ver que hay diferentes tipos de contenedores para almacenar datos múltiples. 8.1 El contenedor vector En R, un vector es una combinación de datos con la particularidad de que todos los datos contenidos en un vector son del mismo tipo. Podemos almacenar por ejemplo múltiples elementos del tipo character o numeric en un vector, pero no ambos. El contenedor vector es importante porque es el elemento básico de R. 8.1.1 Crear un vector Para crear un vector utilizaremos la función c() que permite combinar elementos en un vector. Los elementos para combinar deben estar separados por comas. miVec01 &lt;- c(1, 2, 3, 4) # un vector de 4 elementos de tipo numeric ; double print(miVec01) ## [1] 1 2 3 4 typeof(miVec01) ## [1] &quot;double&quot; is.vector(miVec01) ## [1] TRUE La funcion is.vector() permite verificar el tipo de contenedor. miVec02 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) print(miVec02) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; typeof(miVec02) ## [1] &quot;character&quot; is.vector(miVec02) ## [1] TRUE miVec03 &lt;- c(TRUE, FALSE, FALSE, TRUE) print(miVec03) ## [1] TRUE FALSE FALSE TRUE typeof(miVec03) ## [1] &quot;logical&quot; is.vector(miVec03) ## [1] TRUE miVecNA &lt;- c(1, NA, 3, NA, 5) print(miVecNA) ## [1] 1 NA 3 NA 5 typeof(miVecNA) ## [1] &quot;double&quot; is.vector(miVecNA) ## [1] TRUE miVec04 &lt;- c(1, &quot;a&quot;) print(miVec04) ## [1] &quot;1&quot; &quot;a&quot; typeof(miVec04) ## [1] &quot;character&quot; is.vector(miVec04) ## [1] TRUE Si combinamos diferentes tipos de datos, R intentará transformar los elementos en un tipo de forma predeterminada. Si como aquí en el objeto miVec03 tenemos los tipos character y numeric, R convertirá todos los elementos en character. miVec05 &lt;- c(factor(&quot;abc&quot;), &quot;def&quot;) print(miVec05) ## [1] &quot;1&quot; &quot;def&quot; typeof(miVec05) ## [1] &quot;character&quot; miVec06 &lt;- c(TRUE, &quot;def&quot;) print(miVec06) ## [1] &quot;TRUE&quot; &quot;def&quot; typeof(miVec06) ## [1] &quot;character&quot; miVec07 &lt;- c(factor(&quot;abc&quot;), 55) print(miVec07) ## [1] 1 55 typeof(miVec07) ## [1] &quot;double&quot; miVec08 &lt;- c(TRUE, 55) print(miVec08) ## [1] 1 55 typeof(miVec08) ## [1] &quot;double&quot; También podemos combinar objetos existentes dentro de un vector. miVec09 &lt;- c(miVec02, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miVec09) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; miVec10 &lt;- c(&quot;aaa&quot;, &quot;aa&quot;, miVec09, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miVec10) ## [1] &quot;aaa&quot; &quot;aa&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; miVec11 &lt;- c(789, miVec01 , 564) print(miVec11) ## [1] 789 1 2 3 4 564 8.1.2 Hacer operaciones con un vector También podemos realizar operaciones en un vector. print(miVec01) ## [1] 1 2 3 4 miVec01 + 1 ## [1] 2 3 4 5 miVec01 - 1 ## [1] 0 1 2 3 miVec01 * 2 ## [1] 2 4 6 8 miVec01 /10 ## [1] 0.1 0.2 0.3 0.4 Las operaciones de un vector a otro también son posibles, pero se debe tener cuidado para asegurar que el número de elementos en un vector sea el mismo que el otro, de lo contrario R realizará el cálculo comenzando desde el inicio del vector mas pequeño. Aquí hay un ejemplo para ilustrar lo que R hace: miVec12 &lt;- c(1, 1, 1, 1, 1, 1, 1, 1, 1) print(miVec12) ## [1] 1 1 1 1 1 1 1 1 1 miVec13 &lt;- c(10, 20, 30) print(miVec13) ## [1] 10 20 30 miVec12 + miVec13 # vectores de diferentes tamaños: atención al resultado ## [1] 11 21 31 11 21 31 11 21 31 miVec14 &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90) print(miVec14) ## [1] 10 20 30 40 50 60 70 80 90 miVec12 + miVec14 # los vectores tienen el mismo tamaño ## [1] 11 21 31 41 51 61 71 81 91 miVec15 &lt;- c(1, 1, 1, 1) print(miVec15) ## [1] 1 1 1 1 miVec15 + miVec13 # vectores de diferentes tamaños y no múltiples ## Warning in miVec15 + miVec13: la taille d&#39;un objet plus long n&#39;est pas ## multiple de la taille d&#39;un objet plus court ## [1] 11 21 31 11 8.1.3 Acceder a los valores de un vector Suele pasar que sea necesario poder acceder a los valores de un vector, es decir, recuperar un valor o un grupo de valores dentro de un vector. Para acceder a un elemento de un vector usamos los corchetes []. Entre los corchetes, podemos usar un número correspondiente al número del elemento en el vector. miVec20 &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90) miVec21 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;) print(miVec20) ## [1] 10 20 30 40 50 60 70 80 90 print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec20[1]) ## [1] 10 print(miVec21[3]) ## [1] &quot;c&quot; También podemos usar la combinación de diferentes elementos (otro vector). print(miVec20[c(1, 5, 9)]) ## [1] 10 50 90 print(miVec21[c(4, 3, 1)]) ## [1] &quot;d&quot; &quot;c&quot; &quot;a&quot; print(miVec21[c(4, 4, 3, 4, 3, 2, 5)]) ## [1] &quot;d&quot; &quot;d&quot; &quot;c&quot; &quot;d&quot; &quot;c&quot; &quot;b&quot; &quot;e&quot; También podemos seleccionar elementos usando un operador de comparación o un operador lógico. print(miVec20[miVec20 &gt;= 50]) ## [1] 50 60 70 80 90 print(miVec20[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))]) ## [1] 50 60 70 print(miVec20[miVec20 != 50]) ## [1] 10 20 30 40 60 70 80 90 print(miVec20[miVec20 == 30]) ## [1] 30 print(miVec20[(miVec20 == 30) | (miVec20 == 50)]) ## [1] 30 50 print(miVec21[miVec21 == &quot;a&quot;]) ## [1] &quot;a&quot; Otra característica interesante es la posibilidad de condicionar los elementos a seleccionar en base a otro vector. print(miVec21[miVec20 &gt;= 50]) ## [1] &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec21[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))]) ## [1] &quot;e&quot; &quot;f&quot; &quot;g&quot; print(miVec21[miVec20 != 50]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec21[miVec20 == 30]) ## [1] &quot;c&quot; print(miVec21[(miVec20 == 30) | (miVec20 == 50)]) ## [1] &quot;c&quot; &quot;e&quot; print(miVec21[(miVec20 == 30) | (miVec21 == &quot;h&quot;)]) ## [1] &quot;c&quot; &quot;h&quot; También es posible excluir ciertos elementos en lugar de seleccionarlos. print(miVec20[-1]) ## [1] 20 30 40 50 60 70 80 90 print(miVec21[-5]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec20[-c(1, 2, 5)]) ## [1] 30 40 60 70 80 90 print(miVec21[-c(1, 2, 5)]) ## [1] &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; Los elementos de un vector también se pueden seleccionar sobre la base de un vector tipo logical. En este caso, solo se seleccionarán elementos con un valor TRUE. miVec22 &lt;- c(TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE) print(miVec21[miVec22]) ## [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;f&quot; &quot;h&quot; &quot;i&quot; 8.1.4 Dar nombres a los elementos de un vector Los elementos de un vector se pueden nombrar para referenciarlos y luego selectionarlos. La función names() recupera los nombres de los elementos de un vector. miVec23 &lt;- c(aaa = 10, bbb = 20, ccc = 30, ddd = 40, eee = 50) print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 30 40 50 print(miVec23[&quot;bbb&quot;]) ## bbb ## 20 print(miVec23[c(&quot;bbb&quot;, &quot;ccc&quot;, &quot;bbb&quot;)]) ## bbb ccc bbb ## 20 30 20 names(miVec23) ## [1] &quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot; &quot;ddd&quot; &quot;eee&quot; 8.1.5 Editar los elementos de un vector Para modificar un vector, operamos de la misma manera que para modificar un objeto simple, con el signo &lt;- y el elemento o los elementos a modificar entre corchetes. print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miVec21[3] &lt;- &quot;zzz&quot; print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;zzz&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miVec21[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))] &lt;- &quot;qwerty&quot; print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;zzz&quot; &quot;d&quot; &quot;qwerty&quot; &quot;qwerty&quot; &quot;qwerty&quot; &quot;h&quot; ## [9] &quot;i&quot; print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 30 40 50 miVec23[&quot;ccc&quot;] &lt;- miVec23[&quot;ccc&quot;] + 100 print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 130 40 50 También podemos cambiar los nombres asociados con los elementos de un vector. print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 130 40 50 names(miVec23)[2] &lt;- &quot;bb_bb&quot; print(miVec23) ## aaa bb_bb ccc ddd eee ## 10 20 130 40 50 Podemos hacer mucho más con un vector y volveremos a su manejo y operaciones posibles en el capítulo sobre funciones. 8.2 El contenedor list El segundo tipo de contenedor que vamos a presentar es el contenedor list, que es también el segundo contenedor después del tipovector debido a su importancia en la programación con R. El contenedor de tipo list le permite almacenar listas de elementos. Contrariamente a lo que vimos antes con el tipo vector, los elementos del tipo list pueden ser diferentes (por ejemplo, un vector de tipo numeric, luego un vector de tipo character). Los elementos del tipo list también pueden ser contenedores diferentes (por ejemplo, un vector, luego una list). El tipo de contenedor list tendrá mas sentido cuando hayamos estudiado los bucles y funciones de la familia apply. 8.2.1 Crear una list Para crear una list usaremos la función list(), que toma elementos (objetos) como argumentos. miList01 &lt;- list() print(miList01) ## list() miList02 &lt;- list(5, &quot;qwerty&quot;, c(4, 5, 6), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList03 &lt;- list(5, &quot;qwerty&quot;, list(c(4, 5, 6), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))) print(miList03) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [[3]][[1]] ## [1] 4 5 6 ## ## [[3]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; La función is.list() se usa para probar si hemos creado un objeto de tipo list. is.list(miList02) ## [1] TRUE typeof(miList02) ## [1] &quot;list&quot; 8.2.2 Acceder a los valores de una list Los elementos del contenedor list son identificables por los corchetes dobles [[ ]]. print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; En el objeto de tipo list miList02, hay cuatro elementos identificables con [[1]], [[2]], [[3]] y [[4]]. Cada uno de los elementos es de tipo vector. El primer elemento tiene un tamaño de 1 con elementos del tipo double, el segundo elemento tiene un tamaño de 1 con elementos del tipo character, el tercero elemento tiene un tamaño de 3 con elementos del tipo double, y el cuarto elemento tiene un tamaño de 3 con elementos del tipo character. typeof(miList02) ## [1] &quot;list&quot; print(miList02[[1]]) ## [1] 5 typeof(miList02[[1]]) ## [1] &quot;double&quot; print(miList02[[2]]) ## [1] &quot;qwerty&quot; typeof(miList02[[2]]) ## [1] &quot;character&quot; print(miList02[[3]]) ## [1] 4 5 6 typeof(miList02[[3]]) ## [1] &quot;double&quot; print(miList02[[4]]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; typeof(miList02[[4]]) ## [1] &quot;character&quot; El acceso al segundo elemento del vector ubicado en la cuarta posición de la list se hace con miList02[[4]][2]. Usamos doble corchetes para el cuarto elemento de la list, luego corchetes simples para el segundo elemento del vector. print(miList02[[4]][2]) ## [1] &quot;b&quot; Como una list puede contener una o más list, podemos acceder a la información buscada combinando corchetes dobles. El objeto miList04 es una list de dos elementos: la list miList02 y la list miList03. El objeto miList03 en sí contiene una list como tercer elemento. Para acceder al primer elemento del vector en la primera posición del elemento en la tercera posición del segundo elemento del list miList04, podemos usar miList04[[2]][[3]][[1]][1]. No hay límite en cuanto a la profundidad de list pero en la práctica raramente hay necesidad de hacer list de list de list. miList04 &lt;- list(miList02, miList03) print(miList04) ## [[1]] ## [[1]][[1]] ## [1] 5 ## ## [[1]][[2]] ## [1] &quot;qwerty&quot; ## ## [[1]][[3]] ## [1] 4 5 6 ## ## [[1]][[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## ## [[2]] ## [[2]][[1]] ## [1] 5 ## ## [[2]][[2]] ## [1] &quot;qwerty&quot; ## ## [[2]][[3]] ## [[2]][[3]][[1]] ## [1] 4 5 6 ## ## [[2]][[3]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; print(miList04[[2]][[3]][[1]][1]) ## [1] 4 Para concretar el ejemplo anterior, podemos imaginar especies de barrenadores del maíz (Sesamia nonagrioides y Ostrinia nubilalis), muestreados en diferentes sitios, con diferentes abundancias en cuatro fechas. Aquí daremos nombres a los elementos de las list. bddInsect &lt;- list(Snonagrioides = list(site01 = c(12, 5, 8, 7), site02 = c(5, 23, 4, 41), site03 = c(12, 0, 0, 0)), Onubilalis = list(site01 = c(12, 1, 2, 3), site02 = c(0, 0, 0, 1), site03 = c(1, 1, 2, 3))) print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 5 23 4 41 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 Leer una larga línea de código como la línea para crear el objeto bddInsect resulta difícil porque la profundidad de los elementos solo se puede deducir de los paréntesis. Es por eso que vamos a reorganizar el código para que sea más legible mediante el margen adicional. El margen adicional implica poner información en diferentes niveles para que podamos identificar rápidamente los diferentes niveles de un código. Para aplicar el margen adicional se presiona la tecla de tabulación. Volveremos al margen adicional con más detalles en el capítulo sobre bucles. Recordemos por el momento que si una línea de código es demasiado larga, podemos saltar de línea y usar el margen adicional. R leerá todo como una sola línea de código. bddInsect &lt;- list( Snonagrioides = list( site01 = c(12, 5, 8, 7), site02 = c(5, 23, 4, 41), site03 = c(12, 0, 0, 0) ), Onubilalis = list( site01 = c(12, 1, 2, 3), site02 = c(0, 0, 0, 1), site03 = c(1, 1, 2, 3) ) ) Podemos seleccionar los datos de abundancia del segundo sitio de la primera especie como previamente bddInsect[[1]][[2]], o alternativamente usando los nombres de los elementos bddInsect$Snonagrioides$site02. Para hacer esto usamos el signo $, o como alternativa el nombre de los elementos con comillas simples o dobles bddInsect[['Snonagrioides']][['sitio02']]. print(bddInsect[[1]][[2]]) ## [1] 5 23 4 41 print(bddInsect$Snonagrioides$site02) ## [1] 5 23 4 41 print(bddInsect[[&#39;Snonagrioides&#39;]][[&#39;site02&#39;]]) ## [1] 5 23 4 41 En cuanto a los vectores, podemos recuperar los nombres de los elementos con la función names(). names(bddInsect) ## [1] &quot;Snonagrioides&quot; &quot;Onubilalis&quot; names(bddInsect[[1]]) ## [1] &quot;site01&quot; &quot;site02&quot; &quot;site03&quot; Cuando usamos los corchetes dobles [[]] o el signo $, R devuelve el contenido del elemento seleccionado. En nuestro ejemplo, los datos de abundancia están contenidos como un vector, por lo que R devuelve un elemento del tipo vector. Si queremos seleccionar un elemento de una list pero manteniendo el formato list, entonces podemos usar corchetes simples []. print(bddInsect[[1]][[2]]) ## [1] 5 23 4 41 typeof(bddInsect[[1]][[2]]) ## [1] &quot;double&quot; is.list(bddInsect[[1]][[2]]) ## [1] FALSE print(bddInsect[[1]][2]) ## $site02 ## [1] 5 23 4 41 typeof(bddInsect[[1]][2]) ## [1] &quot;list&quot; is.list(bddInsect[[1]][2]) ## [1] TRUE El uso de corchetes simples [] es útil cuando queremos recuperar varios elementos de una list. Por ejemplo, para seleccionar las abundancias de insectos de los primeros dos sitios de la primera especie, usaremos bddInsect [[1]][c(1, 2)] o alternativamente bddInsect[[1]][c(&quot;site01&quot;, &quot;sitio02&quot;)]. print(bddInsect[[1]][c(1, 2)]) ## $site01 ## [1] 12 5 8 7 ## ## $site02 ## [1] 5 23 4 41 print(bddInsect[[1]][c(&quot;site01&quot;, &quot;site02&quot;)]) ## $site01 ## [1] 12 5 8 7 ## ## $site02 ## [1] 5 23 4 41 8.2.3 Editar una list Una list se puede modificar de la misma manera que para el contenedor vector, es decir, haciendo referencia con corchetes al elemento que queremos modificar. print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList02[[1]] &lt;- 12 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList02[[4]] &lt;- c(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;d&quot; &quot;e&quot; &quot;f&quot; miList02[[4]] &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, miList02[[4]], &quot;g&quot;, &quot;h&quot;, &quot;i&quot;) print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[4]][5] &lt;- &quot;eee&quot; print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[3]] &lt;- miList02[[3]] * 10 - 1 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 49 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[3]][2] &lt;- miList02[[1]] * 100 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 1200 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 5 23 4 41 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 bddInsect[[&#39;Snonagrioides&#39;]][[&#39;site02&#39;]] &lt;- c(2, 4, 6, 8) print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 2 4 6 8 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 Para combinar dos list, simplemente usamos la función c() que hemos usado para crear un vector. miList0203 &lt;- c(miList02, miList03) print(miList0203) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 1200 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] &quot;qwerty&quot; ## ## [[7]] ## [[7]][[1]] ## [1] 4 5 6 ## ## [[7]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Un objeto de tipo list se puede transformar en vector con la función unlist() si el formato de los elementos de la lista lo permite (un vector solo puede contener elementos del mismo tipo). miList05 &lt;- list(&quot;a&quot;, c(&quot;b&quot;, &quot;c&quot;), &quot;d&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; miVec24 &lt;- unlist(miList05) print(miVec24) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; miList06 &lt;- list(c(1, 2, 3), c(4, 5, 6, 7), 8, 9, c(10, 11)) print(miList06) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] 4 5 6 7 ## ## [[3]] ## [1] 8 ## ## [[4]] ## [1] 9 ## ## [[5]] ## [1] 10 11 miVec25 &lt;- unlist(miList06) print(miVec25) ## [1] 1 2 3 4 5 6 7 8 9 10 11 Para agregar un elemento a una list, podemos usar la función c() o los corchetes dobles [[ ]]. print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; miList05 &lt;- c(miList05, &quot;e&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; miList05[[5]] &lt;- c(&quot;fgh&quot;, &quot;ijk&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; ## ## [[5]] ## [1] &quot;fgh&quot; &quot;ijk&quot; Para eliminar un elemento de una list, la técnica más rápida es establecer NULL en el elemento que deseamos eliminar. print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; ## ## [[5]] ## [1] &quot;fgh&quot; &quot;ijk&quot; miList05[[2]] &lt;- NULL print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;d&quot; ## ## [[3]] ## [1] &quot;e&quot; ## ## [[4]] ## [1] &quot;fgh&quot; &quot;ijk&quot; 8.3 El contenedor data.frame El contenedor data.frame se puede comparar a una tabla. Este es en realidad un caso especial de list donde todos los elementos de la list tienen el mismo tamaño. 8.3.1 Crear un data.frame Para crear un data.frame usamos la función data.frame() que toma como argumentos los elementos de la tabla que queremos crear. Los elementos son del tipo vector y son todos del mismo tamaño. Podemos dar un nombre a cada columna (vector) de nuestra tabla (data.frame). # crear un data.frame miDf01 &lt;- data.frame( numbers = c(1, 2, 3, 4), logicals = c(TRUE, TRUE, FALSE, TRUE), characters = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) ) print(miDf01) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 3 3 FALSE c ## 4 4 TRUE d # crear vectores, y el data.frame numbers &lt;- c(1, 2, 3, 4) logicals &lt;- c(TRUE, TRUE, FALSE, TRUE) characters &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) miDf01 &lt;- data.frame(numbers, logicals, characters) print(miDf01) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 3 3 FALSE c ## 4 4 TRUE d 8.3.2 Acceder a los elementos de un data.frame El acceso a los diferentes valores de un data.frame se puede hacer de la misma manera que para un contenedor de tipo list. print(miDf01$numbers) # vector ## [1] 1 2 3 4 print(miDf01[[1]]) # vector ## [1] 1 2 3 4 print(miDf01[1]) # list ## numbers ## 1 1 ## 2 2 ## 3 3 ## 4 4 print(miDf01[&quot;numbers&quot;]) # list ## numbers ## 1 1 ## 2 2 ## 3 3 ## 4 4 print(miDf01[[&quot;numbers&quot;]]) # vector ## [1] 1 2 3 4 También podemos usar otra forma que consiste en especificar la línea o las líneas seguidas de una coma (con un espacio después de la coma), y luego la columna o columnas entre corchetes. Si se omite la información de línea o columna, R mostrará todas las líneas o columnas. Nuevamente podemos usar el número correspondiente a un elemento o el nombre del elemento que queremos seleccionar. myRow &lt;- 2 myCol &lt;- 1 print(miDf01[myRow, myCol]) ## [1] 2 print(miDf01[myRow, ]) ## numbers logicals characters ## 2 2 TRUE b print(miDf01[, myCol]) ## [1] 1 2 3 4 myCol &lt;- &quot;numbers&quot; print(miDf01[, myCol]) ## [1] 1 2 3 4 Es posible seleccionar múltiples líneas o columnas. print(miDf01[, c(1, 2)]) ## numbers logicals ## 1 1 TRUE ## 2 2 TRUE ## 3 3 FALSE ## 4 4 TRUE print(miDf01[c(2, 1), ]) ## numbers logicals characters ## 2 2 TRUE b ## 1 1 TRUE a Como cada columna está en formato vector, también podemos hacer una selección que depende del contenido con operadores de comparación y operadores lógicos. miDfSub01 &lt;- miDf01[miDf01$numbers &gt; 2, ] print(miDfSub01) ## numbers logicals characters ## 3 3 FALSE c ## 4 4 TRUE d miDfSub02 &lt;- miDf01[(miDf01$logicals == TRUE) &amp; (miDf01$numbers &lt; 2), ] print(miDfSub02) ## numbers logicals characters ## 1 1 TRUE a miDfSub03 &lt;- miDf01[(miDf01$numbers %% 2) == 0, ] print(miDfSub03) ## numbers logicals characters ## 2 2 TRUE b ## 4 4 TRUE d miDfSub04 &lt;- miDf01[((miDf01$numbers %% 2) == 0) | (miDf01$logicals == TRUE), ] print(miDfSub04) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 4 4 TRUE d 8.3.3 Modificar un data.frame Para agregar un elemento a un data.frame, procedemos como para un contenedor de tipo list. Es necesario asegurarse de que el nuevo elemento sea del mismo tamaño que los otros elementos de nuestro data.frame. Por defecto, un nuevo elemento en data.frame toma el nombre de la letra V seguido del número de la columna. Podemos cambiar los nombres de las columnas con la función colnames(). Podemos nombrar las líneas con la función rownames(). newVec &lt;- c(4, 5, 6, 7) miDf01[[4]] &lt;- newVec print(miDf01) ## numbers logicals characters V4 ## 1 1 TRUE a 4 ## 2 2 TRUE b 5 ## 3 3 FALSE c 6 ## 4 4 TRUE d 7 print(colnames(miDf01)) ## [1] &quot;numbers&quot; &quot;logicals&quot; &quot;characters&quot; &quot;V4&quot; colnames(miDf01)[4] &lt;- &quot;newVec&quot; print(miDf01) ## numbers logicals characters newVec ## 1 1 TRUE a 4 ## 2 2 TRUE b 5 ## 3 3 FALSE c 6 ## 4 4 TRUE d 7 print(rownames(miDf01)) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; rownames(miDf01) &lt;- c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;, &quot;row4&quot;) print(miDf01) ## numbers logicals characters newVec ## row1 1 TRUE a 4 ## row2 2 TRUE b 5 ## row3 3 FALSE c 6 ## row4 4 TRUE d 7 newVec2 &lt;- c(40, 50, 60, 70) miDf01$newVec2 &lt;- newVec2 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 40 ## row2 2 TRUE b 5 50 ## row3 3 FALSE c 6 60 ## row4 4 TRUE d 7 70 Como el contenedor de tipo data.frame es un caso especial de list, la selección y modificación se realiza como un contenedor de tipo list. Dado que los elementos de un data.frame son del tipo vector, la selección y la modificación de los elementos de un data.frame se hace como para un contenedor vector. miDf01$newVec2 &lt;- miDf01$newVec2 * 2 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 80 ## row2 2 TRUE b 5 100 ## row3 3 FALSE c 6 120 ## row4 4 TRUE d 7 140 miDf01$newVec2 + miDf01$newVec ## [1] 84 105 126 147 miDf01$newVec2[2] &lt;- 0 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 80 ## row2 2 TRUE b 5 0 ## row3 3 FALSE c 6 120 ## row4 4 TRUE d 7 140 Un vector se puede transformar en data.frame con la función as.data.frame(). print(newVec2) ## [1] 40 50 60 70 print(as.data.frame(newVec2)) ## newVec2 ## 1 40 ## 2 50 ## 3 60 ## 4 70 is.data.frame(newVec2) ## [1] FALSE is.data.frame(as.data.frame(newVec2)) ## [1] TRUE 8.4 El contenedor matrix El contenedor matrix se puede ver como un vector de dos dimensiones: líneas y columnas. Corresponde a una matriz en matemáticas, y puede contener solo un tipo de datos (logical, numeric, character, …). 8.4.1 Crear una matrix Para crear una matrix primero creamos un vector, luego especificamos el número deseado de líneas y columnas en la función matrix(). vecForMatrix &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12) miMat &lt;- matrix(vecForMatrix, nrow = 3, ncol = 4) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 No tenemos que especificar el número de líneas nrow y el número de columnas ncol. Si usamos uno u otro de estos argumentos, R calculará automáticamente el número correspondiente. miMat &lt;- matrix(vecForMatrix, nrow = 3) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 miMat &lt;- matrix(vecForMatrix, ncol = 4) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Observamos que los diferentes elementos del vector inicial aparecen por columna. Si queremos llenar la matrix empezando por línea, entonces tenemos que dar como valor TRUE al argumento byrow. miMat &lt;- matrix(vecForMatrix, nrow = 3, byrow = TRUE) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 También podemos dar un nombre a las líneas y columnas de nuestra matrix cuando se crea con el argumento dimnames que toma como valor una list de dos elementos: el nombre de las líneas y luego el nombre de las columnas. También podemos cambiar el nombre de las líneas y columnas a posteriori con las funciones rownames() y colnames(). miMat &lt;- matrix( vecForMatrix, nrow = 3, byrow = TRUE, dimnames = list(c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;), c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;, &quot;c4&quot;)) ) print(miMat) ## c1 c2 c3 c4 ## r1 1 2 3 4 ## r2 5 6 7 8 ## r3 9 10 11 12 colnames(miMat) &lt;- c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;, &quot;col4&quot;) rownames(miMat) &lt;- c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;) print(miMat) ## col1 col2 col3 col4 ## row1 1 2 3 4 ## row2 5 6 7 8 ## row3 9 10 11 12 Es posible crear una matrix desde un data.frame con la función as.matrix(). Tenemos que verificar que nuestra data.frame contenga solo elementos del mismo tipo (por ejemplo, elementos de tipo numeric). vecForMat01 &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12) vecForMat02 &lt;- vecForMat01 * 10 vecForMat03 &lt;- vecForMat01 / 10 dfForMat &lt;- data.frame(vecForMat01, vecForMat02, vecForMat03) print(dfForMat) ## vecForMat01 vecForMat02 vecForMat03 ## 1 1 10 0.1 ## 2 2 20 0.2 ## 3 3 30 0.3 ## 4 4 40 0.4 ## 5 5 50 0.5 ## 6 6 60 0.6 ## 7 7 70 0.7 ## 8 8 80 0.8 ## 9 9 90 0.9 ## 10 10 100 1.0 ## 11 11 110 1.1 ## 12 12 120 1.2 is.matrix(dfForMat) ## [1] FALSE as.matrix(dfForMat) ## vecForMat01 vecForMat02 vecForMat03 ## [1,] 1 10 0.1 ## [2,] 2 20 0.2 ## [3,] 3 30 0.3 ## [4,] 4 40 0.4 ## [5,] 5 50 0.5 ## [6,] 6 60 0.6 ## [7,] 7 70 0.7 ## [8,] 8 80 0.8 ## [9,] 9 90 0.9 ## [10,] 10 100 1.0 ## [11,] 11 110 1.1 ## [12,] 12 120 1.2 is.matrix(as.matrix(dfForMat)) ## [1] TRUE También podemos crear una matrix desde un vector con la función as.matrix() (matriz de una sola columna). as.matrix(vecForMat01) ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 ## [6,] 6 ## [7,] 7 ## [8,] 8 ## [9,] 9 ## [10,] 10 ## [11,] 11 ## [12,] 12 8.4.2 Manipular y hacer operaciones en una matrix Todas las operaciones término a término son posibles con una matrix. # operaciones término a término miMat01 &lt;- matrix(vecForMat01, ncol = 3) miVecOp &lt;- c(1, 10, 100, 1000) miMat01 * miVecOp ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 20 60 100 ## [3,] 300 700 1100 ## [4,] 4000 8000 12000 miMat01 + miVecOp ## [,1] [,2] [,3] ## [1,] 2 6 10 ## [2,] 12 16 20 ## [3,] 103 107 111 ## [4,] 1004 1008 1012 miMat01 / miMat01 ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 1 1 1 ## [3,] 1 1 1 ## [4,] 1 1 1 miMat01 - 10 ## [,1] [,2] [,3] ## [1,] -9 -5 -1 ## [2,] -8 -4 0 ## [3,] -7 -3 1 ## [4,] -6 -2 2 Para realizar operaciones algebraicas, podemos usar la función %*%. # operaciones algebraicas miVecConf &lt;- c(1, 10, 100) miMat01 %*% miVecConf ## [,1] ## [1,] 951 ## [2,] 1062 ## [3,] 1173 ## [4,] 1284 miMat02 &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol = 3) print(miMat02) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 miMat02 %*% miMat02 ## [,1] [,2] [,3] ## [1,] 30 66 102 ## [2,] 36 81 126 ## [3,] 42 96 150 La diagonal de una matrix se puede obtener con la función diag() y el determinante de una matrix con la función det(). print(miMat02) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 diag(miMat02) ## [1] 1 5 9 det(miMat02) ## [1] 0 Suele ser útil poder hacer una transposición de matrix (columnas en líneas o líneas en columnas). Para eso, están las funciones aperm() o t(). la función t() es más genérica y también funciona con data.frame. aperm(miMat01) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 t(miMat01) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 8.4.3 Acceder a los elementos de una matrix Tal como hemos hecho con los data.frame, podemos acceder a los elementos de una matrix especificando un número de línea y un número de columna entre corchetes simples [ ], y separados por una coma. Si i es el número de línea y j es el número de columna, entonces miMat01[i, j] devuelve el elemento en la línea i y en la columnaj. miMat01[i,] devuelve todos los elementos de la línea i, y miMat01[, j] todos los elementos de la columna j. Múltiples selecciones son posibles. También podemos acceder a un elemento de acuerdo con su posición en la matrix entre corchetes simples [ ] contando por columna y luego por línea. En nuestro ejemplo, el valor del décimo elemento es 10. i &lt;- 2 j &lt;- 1 print(miMat01[i, j]) ## [1] 2 print(miMat01[i, ]) ## [1] 2 6 10 print(miMat01[, j]) ## [1] 1 2 3 4 print(miMat01[c(1, 2), c(2, 3)]) ## [,1] [,2] ## [1,] 5 9 ## [2,] 6 10 print(miMat01[10]) ## [1] 10 8.5 El contenedor array El contenedor array es una generalización del contenedor de tipo matrix. Donde el tipo matrix tiene dos dimensiones (líneas y columnas), el tipo array tiene un número indefinido de dimensiones. Podemos saber el número de dimensiones de un array (y por lo tanto una matrix) con la función dim(). dim(miMat01) ## [1] 4 3 8.5.1 Crear un array La creación de una array es similar a la de una matrix con una dimensión extra. miVecArr &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9) miArray &lt;- array(miVecArr, dim = c(3, 3, 2)) print(miArray) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 dim(miArray) ## [1] 3 3 2 is.array(miArray) ## [1] TRUE miVecArr02 &lt;- 10 * miVecArr miArray02 &lt;- array(c(miVecArr, miVecArr02), dim = c(3, 3, 2)) print(miArray02) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 40 70 ## [2,] 20 50 80 ## [3,] 30 60 90 dim(miArray02) ## [1] 3 3 2 is.array(miArray02) ## [1] TRUE Podemos dar nombres a líneas y columnas, pero también a elementos. miArray02 &lt;- array( c(miVecArr, miVecArr02), dim = c(3, 3, 2), dimnames = list( c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;), c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;), c(&quot;matrix1&quot;, &quot;matrix2&quot;) ) ) print(miArray02) ## , , matrix1 ## ## c1 c2 c3 ## r1 1 4 7 ## r2 2 5 8 ## r3 3 6 9 ## ## , , matrix2 ## ## c1 c2 c3 ## r1 10 40 70 ## r2 20 50 80 ## r3 30 60 90 8.5.2 Manipular un array La manipulación de un array se hace de la misma manera que para una matrix. Para acceder a los diferentes elementos de un array, simplemente hay que especificar la línea i, la columna j, y la matrix k. i &lt;- 2 j &lt;- 1 k &lt;- 1 print(miArray02[i, j, k]) ## [1] 2 print(miArray02[, j, k]) ## r1 r2 r3 ## 1 2 3 print(miArray02[i, , k]) ## c1 c2 c3 ## 2 5 8 print(miArray02[i, j, ]) ## matrix1 matrix2 ## 2 20 8.6 Conclusión Felicitaciones! Ahora conocemos los principales tipos de objetos que usaremos con R. Un objeto se caracteriza por sus atributos: el tipo de contenedor (vector, data.frame, matrix, array) el tipo de contenido de cada elemento (numeric, logical, character, …) el valor de cada uno de los elementos (5, “qwerty”, TRUE, …) Todos estos objetos se almacenan temporalmente en el entorno global de R (en la memoria RAM de nuestra computadora). El siguiente capítulo tratará las funciones y resaltará uno de los aspectos que hace que R sea tan poderoso para analizar y administrar nuestros datos. "],
["fonctions.html", " 9 Las funciones 9.1 ¿Qué es una función? 9.2 Las funciones más comunes 9.3 Otras funciones útiles 9.4 Algunos ejercicios para practicar 9.5 Escribir una función 9.6 Otras funciones desarrolladas por la comunidad de usuarios: los packages 9.7 Conclusión", " 9 Las funciones 9.1 ¿Qué es una función? Con este capítulo vamos a echar un primer vistazo al poder de R a través de las funciones. Una función es un conjunto de líneas de código para realizar una tarea en particular. Hemos visto muchas funciones en capítulos anteriores, unas simples como la función + para añadir números, o otras más complejas como c() o data.frame() que permiten crear un vector o data.frame. En cualquier caso, se puede reconocer una función gracias a los paréntesis que la siguen en los cuales vamos a ingresar argumentos. Los argumentos corresponden a la información que queremos transmitir a nuestra función para que realice la tarea que queremos lograr. Para funciones simples como +, los paréntesis han sido eliminados para que el código sea más fácil de leer, pero es una función que puede usarse con paréntesis si usamos el signo + entre comillas. Los argumentos son los números que queremos agregar. 5 + 2 ## [1] 7 &#39;+&#39;(5, 2) ## [1] 7 En este capítulo nos enfocaremos en las funciones más comunes. No se trata de aprender todo de memoria, sino de saber que existen estas funciones y de poder consultar más adelante este capítulo como referencia. ¡Con tiempo y práctica eventualmente los sabremos de memoria! Hay más de 1000 funciones en la versión básica de R, y más de 10000 paquetes adicionales que se pueden instalar, cada uno con docenas de funciones. Antes de comenzar a escribir una nueva función, siempre debemos verificar que ya no exista. 9.2 Las funciones más comunes Para trabajar con las funciones, vamos a usar los datos iris que están incluidos con la versión básica de R y que corresponden a la longitud y el ancho de los sépalos y pétalos de diferentes especies de iris. Los datos iris estan en una data.frame de 5 columnas y 150 líneas. Para obtener más información sobre los datos iris, podemos consultar la documentación R con la función help(iris). El acceso a la documentación es el tema de la siguiente sección. 9.2.1 El acceso a la documentación 9.2.1.1 help() La función esencial de R es acceder a la documentación (en ingles). Todas las funciones R tienen documentación. Podemos acceder a la documentación con la función help() o usando el atajo ?. help(matrix) # equivalente a ?matrix La documentación siempre está estructurada de la misma manera. Primero tenemos el nombre de la función buscada matrix, seguida entre llaves por el nombre del paquete R cuya función depende. Veremos cómo instalar paquetes adicionales más adelante. Por ahora tenemos los que vienen con la versión básica de R. Aquí podemos ver que la función matrix() depende del paquete base. Podemos ver la etiqueta de la función (Matrices), seguida de los parafos Description, Usage, y Arguments. Algunas veces se agregan los párrafos Details, Note, References y See also. El último párrafo es Ejemplos. La última línea de la documentación permite volver al índice del paquete del que depende la función consultada. Al copiar help(matrix) en nuestra consola R, podemos ver que el párrafo Description indica lo que hace la función. En el caso de help(matrix), hay tres funciones: matrix(), as.matrix() y is.matrix(). # Description # matrix creates a matrix from the given set of values. # as.matrix attempts to turn its argument into a matrix. # is.matrix tests if its argument is a (strict) matrix. El párrafo Usage explica cómo usar la función y cuáles son los valores predeterminados para cada parámetro. # Usage # matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, # dimnames = NULL) La función matrix() puede tomar 5 argumentos: data, nrow, ncol, byrow, y dimnames. Podemos ver que por defecto una matrix consistirá de una sola línea y una sola columna, y que la información se completará por columna. El párrafo Arguments detalla los valores y el tipo de contenedor de cada argumento de nuestra función. Por ejemplo, podemos ver que el argumento dimnames debe ser del tipo list. Es por eso que hemos usado este formato en la sección matrix. # Arguments # data an optional data vector (including a list or expression vector). # Non-atomic classed R objects are coerced by as.vector and all # attributes discarded. # nrow the desired number of rows. # ncol the desired number of columns. # byrow logical. If FALSE (the default) the matrix is filled by columns, # otherwise the matrix is filled by rows. # dimnames A dimnames attribute for the matrix: NULL or a list of length 2 # giving the row and column names respectively. An empty list is # treated as NULL, and a list of length one as row names. The # list can be named, and the list names will be used as names for # the dimensions. El párrafo Details proporciona elementos adicionales en la función. El párrafo Examples proporciona ejemplos reproducibles en la consola. ## Example of setting row and column names mdat &lt;- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE, dimnames = list(c(&quot;row1&quot;, &quot;row2&quot;), c(&quot;C.1&quot;, &quot;C.2&quot;, &quot;C.3&quot;))) mdat ## C.1 C.2 C.3 ## row1 1 2 3 ## row2 11 12 13 El nombre de los argumentos no es necesario para que una función sea interpretada correctamente por R. Sin embargo, es mejor usar explicitamente el nombre de los argumentos seguidos por el signo = para que el código sea más legible. # buen ejemplo mdat &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2, ncol = 3, byrow = TRUE) # mal ejemplo mdat &lt;- matrix(c(1, 2, 3, 11, 12, 13), 2, 3, TRUE) 9.2.1.2 help.search() La función help.search() o ?? permite buscar una expresión en toda la documentación. Es útil cuando buscamos una función sin saber el nombre exacto de la función en R. help.search(&quot;average&quot;) La función help.search() devuelve una página que contiene la lista de páginas donde se encontró la expresión en la forma package-name::function-name. 9.2.2 Ver los datos 9.2.2.1 str() La función str() permite visualizar la estructura interna de un objeto, como se indica en la documentación que podemos consultar con help(str). str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... La función str() devuelve el tipo de objeto (data.frame), el número de observaciones (150), el número de variables (5), el nombre de cada variable (Sepal.Length , Sepal.Width, Petal.Length, Petal.Width, y Species), el tipo de cada variable (num,Factor), y los primeros valores de cada una de las variables. Es una función útil para echar un vistazo a un conjunto de datos, pero también para verificar que los datos sean del tipo requirido antes de realizar un análisis estadístico. 9.2.2.2 head() y tail() La función head() devuelve los primeros valores de un objeto, y la función tail() devuelve los últimos valores de un objeto. Por defecto, se devuelven seis valores, el argumento n controla el número de valores a devolver. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa tail(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica head(iris, n = 2) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa 9.2.2.3 names() Ya hemos visto la función names(), que permite conocer los nombres de los elementos de un objeto, pero también asignar nombres a los elementos de un objeto como a un matrix, a una list o a un data.frame. names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; irisCopy &lt;- iris names(irisCopy) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) names(irisCopy) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; 9.2.2.4 cat() et print() La función cat() se usa para mostrar el contenido de un objeto mientras que la función print() devuelve el valor de un objeto con la capacidad de realizar conversiones. cat(names(iris)) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species print(names(iris)) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; cat(iris[1, 1]) ## 5.1 print(iris[1, 1]) ## [1] 5.1 print(iris[1, 1], digits = 0) ## [1] 5 9.2.3 Manipular los datos 9.2.3.1 rank() La función rank() devuelve el número de la posición ordenada de cada elemento de un conjunto de elementos. En el caso de elementos del mismo valor, el argumento ties.method hace posible hacer una elección sobre la clasificación. Como con todas las funciones, los detalles están presentes en la documentación. vecManip &lt;- c(10, 20, 30, 70, 60, 50, 40) rank(vecManip) ## [1] 1 2 3 7 6 5 4 vecManip2 &lt;- c(10, 20, 30, 10, 50, 10, 40) rank(vecManip2) ## [1] 2 4 5 2 7 2 6 rank(vecManip2, ties.method = &quot;first&quot;) ## [1] 1 4 5 2 7 3 6 rank(vecManip2, ties.method = &quot;min&quot;) ## [1] 1 4 5 1 7 1 6 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 rank(iris[, 1], ties.method = &quot;average&quot;) ## [1] 37.0 19.5 10.5 7.5 27.5 49.5 7.5 27.5 3.0 19.5 49.5 ## [12] 14.0 14.0 1.0 77.0 69.5 49.5 37.0 69.5 37.0 49.5 37.0 ## [23] 7.5 37.0 14.0 27.5 27.5 43.5 43.5 10.5 14.0 49.5 43.5 ## [34] 56.0 19.5 27.5 56.0 19.5 3.0 37.0 27.5 5.0 3.0 27.5 ## [45] 37.0 14.0 37.0 7.5 46.0 27.5 138.0 112.0 135.5 56.0 118.0 ## [56] 69.5 104.0 19.5 121.5 43.5 27.5 82.0 86.5 92.5 62.5 126.5 ## [67] 62.5 77.0 97.5 62.5 82.0 92.5 104.0 92.5 112.0 121.5 132.0 ## [78] 126.5 86.5 69.5 56.0 56.0 77.0 86.5 49.5 86.5 126.5 104.0 ## [89] 62.5 56.0 56.0 92.5 77.0 27.5 62.5 69.5 69.5 97.5 37.0 ## [100] 69.5 104.0 77.0 139.0 104.0 118.0 145.0 19.5 143.0 126.5 141.0 ## [111] 118.0 112.0 132.0 69.5 77.0 112.0 118.0 147.5 147.5 86.5 135.5 ## [122] 62.5 147.5 104.0 126.5 141.0 97.5 92.5 112.0 141.0 144.0 150.0 ## [133] 112.0 104.0 92.5 147.5 104.0 112.0 86.5 135.5 126.5 135.5 77.0 ## [144] 132.0 126.5 126.5 104.0 118.0 97.5 82.0 # help(rank) # ... # Usage # rank(x, na.last = TRUE, # ties.method = c(&quot;average&quot;, &quot;first&quot;, &quot;last&quot;, # &quot;random&quot;, &quot;max&quot;, &quot;min&quot;)) 9.2.3.2 order() La función order() devuelve el número de la reorganización de los elementos en función de su posición. Es muy útil, por ejemplo, para ordenar un data.frame en función de una columna. print(vecManip2) ## [1] 10 20 30 10 50 10 40 rank(vecManip2) ## [1] 2 4 5 2 7 2 6 order(vecManip2) ## [1] 1 4 6 2 3 7 5 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 rank(iris[, 1]) ## [1] 37.0 19.5 10.5 7.5 27.5 49.5 7.5 27.5 3.0 19.5 49.5 ## [12] 14.0 14.0 1.0 77.0 69.5 49.5 37.0 69.5 37.0 49.5 37.0 ## [23] 7.5 37.0 14.0 27.5 27.5 43.5 43.5 10.5 14.0 49.5 43.5 ## [34] 56.0 19.5 27.5 56.0 19.5 3.0 37.0 27.5 5.0 3.0 27.5 ## [45] 37.0 14.0 37.0 7.5 46.0 27.5 138.0 112.0 135.5 56.0 118.0 ## [56] 69.5 104.0 19.5 121.5 43.5 27.5 82.0 86.5 92.5 62.5 126.5 ## [67] 62.5 77.0 97.5 62.5 82.0 92.5 104.0 92.5 112.0 121.5 132.0 ## [78] 126.5 86.5 69.5 56.0 56.0 77.0 86.5 49.5 86.5 126.5 104.0 ## [89] 62.5 56.0 56.0 92.5 77.0 27.5 62.5 69.5 69.5 97.5 37.0 ## [100] 69.5 104.0 77.0 139.0 104.0 118.0 145.0 19.5 143.0 126.5 141.0 ## [111] 118.0 112.0 132.0 69.5 77.0 112.0 118.0 147.5 147.5 86.5 135.5 ## [122] 62.5 147.5 104.0 126.5 141.0 97.5 92.5 112.0 141.0 144.0 150.0 ## [133] 112.0 104.0 92.5 147.5 104.0 112.0 86.5 135.5 126.5 135.5 77.0 ## [144] 132.0 126.5 126.5 104.0 118.0 97.5 82.0 order(iris[, 1]) ## [1] 14 9 39 43 42 4 7 23 48 3 30 12 13 25 31 46 2 ## [18] 10 35 38 58 107 5 8 26 27 36 41 44 50 61 94 1 18 ## [35] 20 22 24 40 45 47 99 28 29 33 60 49 6 11 17 21 32 ## [52] 85 34 37 54 81 82 90 91 65 67 70 89 95 122 16 19 56 ## [69] 80 96 97 100 114 15 68 83 93 102 115 143 62 71 150 63 79 ## [86] 84 86 120 139 64 72 74 92 128 135 69 98 127 149 57 73 88 ## [103] 101 104 124 134 137 147 52 75 112 116 129 133 138 55 105 111 117 ## [120] 148 59 76 66 78 87 109 125 141 145 146 77 113 144 53 121 140 ## [137] 142 51 103 110 126 130 108 131 106 118 119 123 136 132 head(iris[order(iris[, 1]),], n = 10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 14 4.3 3.0 1.1 0.1 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 39 4.4 3.0 1.3 0.2 setosa ## 43 4.4 3.2 1.3 0.2 setosa ## 42 4.5 2.3 1.3 0.3 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 23 4.6 3.6 1.0 0.2 setosa ## 48 4.6 3.2 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa 9.2.3.3 sort() La función sort() se usa para ordenar los elementos de un objeto. No permite la clasificación por más de una variable, como es el caso de order(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 sort(vecManip2) ## [1] 10 10 10 20 30 40 50 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 sort(iris[, 1]) ## [1] 4.3 4.4 4.4 4.4 4.5 4.6 4.6 4.6 4.6 4.7 4.7 4.8 4.8 4.8 4.8 4.8 4.9 ## [18] 4.9 4.9 4.9 4.9 4.9 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.1 5.1 ## [35] 5.1 5.1 5.1 5.1 5.1 5.1 5.1 5.2 5.2 5.2 5.2 5.3 5.4 5.4 5.4 5.4 5.4 ## [52] 5.4 5.5 5.5 5.5 5.5 5.5 5.5 5.5 5.6 5.6 5.6 5.6 5.6 5.6 5.7 5.7 5.7 ## [69] 5.7 5.7 5.7 5.7 5.7 5.8 5.8 5.8 5.8 5.8 5.8 5.8 5.9 5.9 5.9 6.0 6.0 ## [86] 6.0 6.0 6.0 6.0 6.1 6.1 6.1 6.1 6.1 6.1 6.2 6.2 6.2 6.2 6.3 6.3 6.3 ## [103] 6.3 6.3 6.3 6.3 6.3 6.3 6.4 6.4 6.4 6.4 6.4 6.4 6.4 6.5 6.5 6.5 6.5 ## [120] 6.5 6.6 6.6 6.7 6.7 6.7 6.7 6.7 6.7 6.7 6.7 6.8 6.8 6.8 6.9 6.9 6.9 ## [137] 6.9 7.0 7.1 7.2 7.2 7.2 7.3 7.4 7.6 7.7 7.7 7.7 7.7 7.9 9.2.3.4 append() Esta función se usa para agregar un elemento a un vector en una posición determinada por el argumento after. Esta función también es más rápida que su alternativa c(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 append(vecManip2, 5) ## [1] 10 20 30 10 50 10 40 5 append(vecManip2, 5, after = 2) ## [1] 10 20 5 30 10 50 10 40 9.2.3.5 cbind() et rbind() Las funciones cbind() y rbind() permiten combinar elementos por columna o por línea. cbind(vecManip2, vecManip2) ## vecManip2 vecManip2 ## [1,] 10 10 ## [2,] 20 20 ## [3,] 30 30 ## [4,] 10 10 ## [5,] 50 50 ## [6,] 10 10 ## [7,] 40 40 rbind(vecManip2, vecManip2) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## vecManip2 10 20 30 10 50 10 40 ## vecManip2 10 20 30 10 50 10 40 9.2.3.6 paste() et paste0() Estas son dos funciones que usaremos mucho a partir de ahora. Las funciones paste() y paste0() se usan para concatenar cadenas de texto. La función paste0() es equivalente a paste() sin proponer un separador entre los elementos a concatenar. La función paste0() también es más rápida. paste(1, &quot;a&quot;) ## [1] &quot;1 a&quot; paste0(1, &quot;a&quot;) ## [1] &quot;1a&quot; paste(1, &quot;a&quot;, sep = &quot;_&quot;) ## [1] &quot;1_a&quot; paste0(&quot;prefix_&quot;, vecManip2, &quot;_suffix&quot;) ## [1] &quot;prefix_10_suffix&quot; &quot;prefix_20_suffix&quot; &quot;prefix_30_suffix&quot; ## [4] &quot;prefix_10_suffix&quot; &quot;prefix_50_suffix&quot; &quot;prefix_10_suffix&quot; ## [7] &quot;prefix_40_suffix&quot; paste(vecManip2, rank(vecManip2), sep = &quot;_&quot;) ## [1] &quot;10_2&quot; &quot;20_4&quot; &quot;30_5&quot; &quot;10_2&quot; &quot;50_7&quot; &quot;10_2&quot; &quot;40_6&quot; 9.2.3.7 rev() La función rev () devuelve los elementos de un objeto en orden inverso. print(vecManip2) ## [1] 10 20 30 10 50 10 40 rev(vecManip2) ## [1] 40 10 50 10 30 20 10 9.2.3.8 %in%() La función %in%() se puede comparar con un operador de comparación. Esta función toma dos objetos como argumentos y devuelve TRUE o FALSE para cada elemento del primer objeto de acuerdo con su presencia o ausencia en el segundo objeto. Para acceder a la documentación de la función, use help('%in%') (con comillas simples). print(vecManip) ## [1] 10 20 30 70 60 50 40 print(vecManip2) ## [1] 10 20 30 10 50 10 40 vecManip %in% vecManip2 ## [1] TRUE TRUE TRUE FALSE FALSE TRUE TRUE vecManip2 %in% vecManip ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE 9.2.4 Funciones matemáticas Ya hemos visto las funciones +, -, *, /, ^, %% y otros operadores aritméticos. R también tiene funciones matemáticas básicas como exponencial exp(), raíz cuadrada sqrt(), valor absoluto abs(), sinus sin(), coseno cos(), tangente tan(), logaritmo log(), logaritmo base 10 log10(), arco coseno acos(), arco sinus asin(), y arco tangente atan(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 exp(vecManip2) ## [1] 2.202647e+04 4.851652e+08 1.068647e+13 2.202647e+04 5.184706e+21 ## [6] 2.202647e+04 2.353853e+17 sqrt(vecManip2) ## [1] 3.162278 4.472136 5.477226 3.162278 7.071068 3.162278 6.324555 abs(-vecManip2) ## [1] 10 20 30 10 50 10 40 sin(vecManip2) ## [1] -0.5440211 0.9129453 -0.9880316 -0.5440211 -0.2623749 -0.5440211 ## [7] 0.7451132 cos(vecManip2) ## [1] -0.8390715 0.4080821 0.1542514 -0.8390715 0.9649660 -0.8390715 ## [7] -0.6669381 tan(vecManip2) ## [1] 0.6483608 2.2371609 -6.4053312 0.6483608 -0.2719006 0.6483608 ## [7] -1.1172149 log(vecManip2) ## [1] 2.302585 2.995732 3.401197 2.302585 3.912023 2.302585 3.688879 log10(vecManip2) ## [1] 1.000000 1.301030 1.477121 1.000000 1.698970 1.000000 1.602060 acos(vecManip2/100) ## [1] 1.470629 1.369438 1.266104 1.470629 1.047198 1.470629 1.159279 asin(vecManip2/100) ## [1] 0.1001674 0.2013579 0.3046927 0.1001674 0.5235988 0.1001674 0.4115168 atan(vecManip2/100) ## [1] 0.09966865 0.19739556 0.29145679 0.09966865 0.46364761 0.09966865 ## [7] 0.38050638 9.2.5 Estadísticas descriptivas También podemos realizar estadísticas descriptivas de forma muy simple a partir de un conjunto de datos. 9.2.5.1 mean() La función mean() devuelve la media. Para ignorar los valores faltantes NA, hay que afectar el valor TRUE al argumento na.rm(). mean(iris[, 1]) ## [1] 5.843333 vecManip3 &lt;- c(1, 5, 6, 8, NA, 45, NA, 14) mean(vecManip3) ## [1] NA mean(vecManip3, na.rm = TRUE) ## [1] 13.16667 9.2.5.2 sd() La función sd() devuelve la desviación estándar. sd(iris[, 1]) ## [1] 0.8280661 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 sd(vecManip3) ## [1] NA sd(vecManip3, na.rm = TRUE) ## [1] 16.16684 9.2.5.3 max() y min() La función max() devuelve el valor máximo y min() el valor mínimo. max(iris[, 1]) ## [1] 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 max(vecManip3) ## [1] NA max(vecManip3, na.rm = TRUE) ## [1] 45 min(iris[, 1]) ## [1] 4.3 min(vecManip3) ## [1] NA min(vecManip3, na.rm = TRUE) ## [1] 1 9.2.5.4 quantile() La función quantile() devuelve el cuantil definido por el argumento probs. quantile(iris[, 1]) ## 0% 25% 50% 75% 100% ## 4.3 5.1 5.8 6.4 7.9 quantile(iris[, 1], probs = c(0, 0.25, 0.5, 0.75, 1)) ## 0% 25% 50% 75% 100% ## 4.3 5.1 5.8 6.4 7.9 quantile(iris[, 1], probs = c(0, 0.1, 0.5, 0.9, 1)) ## 0% 10% 50% 90% 100% ## 4.3 4.8 5.8 6.9 7.9 9.2.5.5 summary() La función summary() devuelve un resumen con el mínimo, primer cuartil, mediana, promedio, tercer cuartil y máximo. summary(iris[, 1]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.300 5.100 5.800 5.843 6.400 7.900 9.2.5.6 median() La función median() devuelve la mediana. median(iris[, 1]) ## [1] 5.8 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 median(vecManip3) ## [1] NA median(vecManip3, na.rm = TRUE) ## [1] 7 9.2.5.7 length() La función length() devuelve el tamaño de un objeto (número de elementos). length(iris[, 1]) ## [1] 150 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 length(vecManip3) ## [1] 8 9.2.5.8 nrow() et ncol() La función nrow() devuelve el número de líneas y la función ncol() el número de columnas en un objeto. nrow(iris) ## [1] 150 ncol(iris) ## [1] 5 9.2.5.9 round(), ceiling(), floor(), et trunc() La función round() le permite seleccionar una cierta cantidad de decimales (0 por defecto) round(5.56874258564) ## [1] 6 round(5.56874258564, digits = 2) ## [1] 5.57 La función ceiling() devuelve el entero más pequeño que no es inferior al valor especificado. ceiling(5.9999) ## [1] 6 ceiling(5.0001) ## [1] 6 La función floor() devuelve el entero más grande que no excede el valor especificado. floor(5.9999) ## [1] 5 floor(5.0001) ## [1] 5 La función trunc() devuelve la parte entera del valor especificado. trunc(5.9999) ## [1] 5 trunc(5.0001) ## [1] 5 9.2.5.10 rowSums() et colSums() Las funciones rowSums() y colSums() calculan la suma de filas y columnas. rowSums(iris[, c(1, 2, 3, 4)]) ## [1] 10.2 9.5 9.4 9.4 10.2 11.4 9.7 10.1 8.9 9.6 10.8 10.0 9.3 8.5 ## [15] 11.2 12.0 11.0 10.3 11.5 10.7 10.7 10.7 9.4 10.6 10.3 9.8 10.4 10.4 ## [29] 10.2 9.7 9.7 10.7 10.9 11.3 9.7 9.6 10.5 10.0 8.9 10.2 10.1 8.4 ## [43] 9.1 10.7 11.2 9.5 10.7 9.4 10.7 9.9 16.3 15.6 16.4 13.1 15.4 14.3 ## [57] 15.9 11.6 15.4 13.2 11.5 14.6 13.2 15.1 13.4 15.6 14.6 13.6 14.4 13.1 ## [71] 15.7 14.2 15.2 14.8 14.9 15.4 15.8 16.4 14.9 12.8 12.8 12.6 13.6 15.4 ## [85] 14.4 15.5 16.0 14.3 14.0 13.3 13.7 15.1 13.6 11.6 13.8 14.1 14.1 14.7 ## [99] 11.7 13.9 18.1 15.5 18.1 16.6 17.5 19.3 13.6 18.3 16.8 19.4 16.8 16.3 ## [113] 17.4 15.2 16.1 17.2 16.8 20.4 19.5 14.7 18.1 15.3 19.2 15.7 17.8 18.2 ## [127] 15.6 15.8 16.9 17.6 18.2 20.1 17.0 15.7 15.7 19.1 17.7 16.8 15.6 17.5 ## [141] 17.8 17.4 15.5 18.2 18.2 17.2 15.7 16.7 17.3 15.8 colSums(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 876.5 458.6 563.7 179.9 9.2.5.11 rowMeans() et colMeans() Las funciones rowMeans() y colMeans() calculan el promedio de filas y columnas. rowMeans(iris[, c(1, 2, 3, 4)]) ## [1] 2.550 2.375 2.350 2.350 2.550 2.850 2.425 2.525 2.225 2.400 2.700 ## [12] 2.500 2.325 2.125 2.800 3.000 2.750 2.575 2.875 2.675 2.675 2.675 ## [23] 2.350 2.650 2.575 2.450 2.600 2.600 2.550 2.425 2.425 2.675 2.725 ## [34] 2.825 2.425 2.400 2.625 2.500 2.225 2.550 2.525 2.100 2.275 2.675 ## [45] 2.800 2.375 2.675 2.350 2.675 2.475 4.075 3.900 4.100 3.275 3.850 ## [56] 3.575 3.975 2.900 3.850 3.300 2.875 3.650 3.300 3.775 3.350 3.900 ## [67] 3.650 3.400 3.600 3.275 3.925 3.550 3.800 3.700 3.725 3.850 3.950 ## [78] 4.100 3.725 3.200 3.200 3.150 3.400 3.850 3.600 3.875 4.000 3.575 ## [89] 3.500 3.325 3.425 3.775 3.400 2.900 3.450 3.525 3.525 3.675 2.925 ## [100] 3.475 4.525 3.875 4.525 4.150 4.375 4.825 3.400 4.575 4.200 4.850 ## [111] 4.200 4.075 4.350 3.800 4.025 4.300 4.200 5.100 4.875 3.675 4.525 ## [122] 3.825 4.800 3.925 4.450 4.550 3.900 3.950 4.225 4.400 4.550 5.025 ## [133] 4.250 3.925 3.925 4.775 4.425 4.200 3.900 4.375 4.450 4.350 3.875 ## [144] 4.550 4.550 4.300 3.925 4.175 4.325 3.950 colMeans(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 5.843333 3.057333 3.758000 1.199333 9.2.5.12 aggregate() La función aggregate() permite agrupar los elementos de un objeto de acuerdo con un valor. El argumento by define el elemento sobre el que se realiza la agrupación. Debe ser del tipo list. aggregate(iris[, c(1, 2, 3, 4)], by = list(iris$Species), FUN = mean) ## Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 setosa 5.006 3.428 1.462 0.246 ## 2 versicolor 5.936 2.770 4.260 1.326 ## 3 virginica 6.588 2.974 5.552 2.026 aggregate(iris[, c(1, 2)], by = list(iris$Species), FUN = summary) ## Group.1 Sepal.Length.Min. Sepal.Length.1st Qu. Sepal.Length.Median ## 1 setosa 4.300 4.800 5.000 ## 2 versicolor 4.900 5.600 5.900 ## 3 virginica 4.900 6.225 6.500 ## Sepal.Length.Mean Sepal.Length.3rd Qu. Sepal.Length.Max. ## 1 5.006 5.200 5.800 ## 2 5.936 6.300 7.000 ## 3 6.588 6.900 7.900 ## Sepal.Width.Min. Sepal.Width.1st Qu. Sepal.Width.Median Sepal.Width.Mean ## 1 2.300 3.200 3.400 3.428 ## 2 2.000 2.525 2.800 2.770 ## 3 2.200 2.800 3.000 2.974 ## Sepal.Width.3rd Qu. Sepal.Width.Max. ## 1 3.675 4.400 ## 2 3.000 3.400 ## 3 3.175 3.800 9.2.5.13 range() La función range() devuelve el mínimo y el máximo. range(iris[, 1]) ## [1] 4.3 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 range(vecManip3) ## [1] NA NA range(vecManip3, na.rm = TRUE) ## [1] 1 45 9.2.5.14 unique() La función unique() devuelve los valores únicos de un objeto (sin duplicados). unique(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.4 4.8 4.3 5.8 5.7 5.2 5.5 4.5 5.3 7.0 6.4 ## [18] 6.9 6.5 6.3 6.6 5.9 6.0 6.1 5.6 6.7 6.2 6.8 7.1 7.6 7.3 7.2 7.7 7.4 ## [35] 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 unique(vecManip3) ## [1] 1 5 6 8 NA 45 14 9.3 Otras funciones útiles No podemos abordar todas las funciones útiles, aquí solo abordaremos ciertas funciones. A lo largo de este libro, se usarán nuevas funciones. Cuando se utiliza una nueva función, nuestro reflejo siempre debe ser el mismo: consultar la documentación con la función help(). 9.3.1 seq_along() La función seq_along() se usa para crear un vector del tamaño del objeto rellenado y tomando como valores los números de 1 a N (N corresponde al número de elementos del objeto). Esta función nos servirá mucho en el capítulo sobre bucles. print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 seq_along(vecManip3) ## [1] 1 2 3 4 5 6 7 8 9.3.2 : La función : permite crear una secuencia desde a hacia b por pasos de 1. Ha sido difícil escribir los capítulos anteriores sin usarlo ya que esta función es muy útil. Aquí estan algunos ejemplos. 5:10 ## [1] 5 6 7 8 9 10 head(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 head(iris[, 1:4]) # ;-) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 miVec01 &lt;- c(1, 2, 3, 4) miVec01 &lt;- 1:4 # ;-) -10:12 ## [1] -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 ## [18] 7 8 9 10 11 12 5:-5 ## [1] 5 4 3 2 1 0 -1 -2 -3 -4 -5 paste(&quot;X&quot;, 1:10, sep = &quot;_&quot;) ## [1] &quot;X_1&quot; &quot;X_2&quot; &quot;X_3&quot; &quot;X_4&quot; &quot;X_5&quot; &quot;X_6&quot; &quot;X_7&quot; &quot;X_8&quot; &quot;X_9&quot; &quot;X_10&quot; 9.3.3 rep() La función rep() permite repetir elementos. miVec12 &lt;- c(1, 1, 1, 1, 1, 1, 1, 1, 1) miVec12 &lt;- rep(1, times = 9) # ;-) rep(&quot;Hola&quot;, times = 3) ## [1] &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; rep(1:3, time = 3) ## [1] 1 2 3 1 2 3 1 2 3 rep(1:3, length.out = 10) ## [1] 1 2 3 1 2 3 1 2 3 1 rep(1:3, each = 3) ## [1] 1 1 1 2 2 2 3 3 3 9.3.4 seq() La función seq() permite crear una secuencia personalizada. seq(from = 0, to = 1, by = 0.2) ## [1] 0.0 0.2 0.4 0.6 0.8 1.0 seq(from = 20, to = 10, length.out = 10) ## [1] 20.00000 18.88889 17.77778 16.66667 15.55556 14.44444 13.33333 ## [8] 12.22222 11.11111 10.00000 letters[seq(from = 1, to = 26, by = 2)] ## [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; &quot;g&quot; &quot;i&quot; &quot;k&quot; &quot;m&quot; &quot;o&quot; &quot;q&quot; &quot;s&quot; &quot;u&quot; &quot;w&quot; &quot;y&quot; rep(seq(from = 1, to = 2, by = 0.5), times = 3) ## [1] 1.0 1.5 2.0 1.0 1.5 2.0 1.0 1.5 2.0 9.3.5 getwd() La función getwd() establece la carpeta de trabajo. Esto corresponde a la ubicación relativa desde la cual R se posiciona para identificar los archivos. Este concepto tendrá sentido cuando veamos cómo importar y exportar datos. getwd() ## [1] &quot;D:/GitHub/myRbook_SP&quot; 9.3.6 setwd() La función setwd() se usa para definir un nuevo directorio de trabajo (carpeta de trabajo). oldWd &lt;- getwd() print(oldWd) ## [1] &quot;D:/GitHub/myRbook_SP&quot; setwd(&quot;..&quot;) getwd() ## [1] &quot;D:/GitHub&quot; setwd(oldWd) getwd() ## [1] &quot;D:/GitHub/myRbook_SP&quot; 9.3.7 list.files() La función list.files () se usa para listar todos los archivos en el directorio de trabajo. list.files(pattern = &quot;(html)$&quot;) # html ## [1] &quot;google_analytics_SP.html&quot; list.files(pattern = &quot;(pdf)$&quot;) # pdf ## character(0) 9.3.8 ls() Al igual que la función list.files() hace posible listar todos los archivos presentes en el directorio de trabajo, la función ls() permite listar todos los objetos presentes en el entorno de trabajo de R. ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;contrib&quot; ## [5] &quot;dfForMat&quot; &quot;factor01&quot; &quot;i&quot; &quot;irisCopy&quot; ## [9] &quot;j&quot; &quot;k&quot; &quot;logicals&quot; &quot;mdat&quot; ## [13] &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [17] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; ## [21] &quot;miList02&quot; &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; ## [25] &quot;miList05&quot; &quot;miList06&quot; &quot;miMat&quot; &quot;miMat01&quot; ## [29] &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; &quot;miVec03&quot; ## [33] &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [37] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; ## [41] &quot;miVec12&quot; &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; ## [45] &quot;miVec20&quot; &quot;miVec21&quot; &quot;miVec22&quot; &quot;miVec23&quot; ## [49] &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; &quot;miVecArr02&quot; ## [53] &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;msg&quot; ## [57] &quot;myCol&quot; &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; ## [61] &quot;myText3&quot; &quot;myText4&quot; &quot;myText5&quot; &quot;nbrRep&quot; ## [65] &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; &quot;oldWd&quot; ## [69] &quot;opAriDf&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; &quot;termino01&quot; ## [73] &quot;termino02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; &quot;vecForMat03&quot; ## [77] &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; &quot;vecManip3&quot; zzz &lt;- &quot;a new object&quot; ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;contrib&quot; ## [5] &quot;dfForMat&quot; &quot;factor01&quot; &quot;i&quot; &quot;irisCopy&quot; ## [9] &quot;j&quot; &quot;k&quot; &quot;logicals&quot; &quot;mdat&quot; ## [13] &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [17] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; ## [21] &quot;miList02&quot; &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; ## [25] &quot;miList05&quot; &quot;miList06&quot; &quot;miMat&quot; &quot;miMat01&quot; ## [29] &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; &quot;miVec03&quot; ## [33] &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [37] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; ## [41] &quot;miVec12&quot; &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; ## [45] &quot;miVec20&quot; &quot;miVec21&quot; &quot;miVec22&quot; &quot;miVec23&quot; ## [49] &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; &quot;miVecArr02&quot; ## [53] &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;msg&quot; ## [57] &quot;myCol&quot; &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; ## [61] &quot;myText3&quot; &quot;myText4&quot; &quot;myText5&quot; &quot;nbrRep&quot; ## [65] &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; &quot;oldWd&quot; ## [69] &quot;opAriDf&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; &quot;termino01&quot; ## [73] &quot;termino02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; &quot;vecForMat03&quot; ## [77] &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; &quot;vecManip3&quot; ## [81] &quot;zzz&quot; 9.3.9 rm() La función rm() permite eliminar un objeto presente en el entorno de trabajo de R. rm(zzz) ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;contrib&quot; ## [5] &quot;dfForMat&quot; &quot;factor01&quot; &quot;i&quot; &quot;irisCopy&quot; ## [9] &quot;j&quot; &quot;k&quot; &quot;logicals&quot; &quot;mdat&quot; ## [13] &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [17] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; ## [21] &quot;miList02&quot; &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; ## [25] &quot;miList05&quot; &quot;miList06&quot; &quot;miMat&quot; &quot;miMat01&quot; ## [29] &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; &quot;miVec03&quot; ## [33] &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [37] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; ## [41] &quot;miVec12&quot; &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; ## [45] &quot;miVec20&quot; &quot;miVec21&quot; &quot;miVec22&quot; &quot;miVec23&quot; ## [49] &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; &quot;miVecArr02&quot; ## [53] &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;msg&quot; ## [57] &quot;myCol&quot; &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; ## [61] &quot;myText3&quot; &quot;myText4&quot; &quot;myText5&quot; &quot;nbrRep&quot; ## [65] &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; &quot;oldWd&quot; ## [69] &quot;opAriDf&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; &quot;termino01&quot; ## [73] &quot;termino02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; &quot;vecForMat03&quot; ## [77] &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; &quot;vecManip3&quot; 9.4 Algunos ejercicios para practicar Aquí hay algunos ejercicios para mejorar el uso de las funciones y aprender nuevas gracias a la documentación. Algunos ejercicios son difíciles, podremos volver a resolverlos más tarde. 9.4.1 Secuencias 9.4.1.1 Vamos a reproducir las siguientes secuencias: -3 -4 -5 -6 -7 -8 -9 -10 –11 -3 -1 1 3 5 7 9 11 3.0 3.2 3.4 3.6 3.8 4.0 20 18 16 14 12 10 8 6 “a” “f” “k” “p” “u” “z” “a” “a” “a” “a” “a” “f” “f” “f” “f” “f” “k” “k” “k” “k” “k” “p” “p” “p” “p” “p” “u” “u” “u” “u” “u” “z” “z” “z” “z” “z” 9.4.1.2 Posibles soluciones (porque siempre hay varias soluciones): -3:-11 ## [1] -3 -4 -5 -6 -7 -8 -9 -10 -11 seq(from = -3, to = 11, by = 2) ## [1] -3 -1 1 3 5 7 9 11 seq(from = 3.0, to = 4.0, by = 0.2) ## [1] 3.0 3.2 3.4 3.6 3.8 4.0 letters[seq(from = 1, to = 26, by = 5)] ## [1] &quot;a&quot; &quot;f&quot; &quot;k&quot; &quot;p&quot; &quot;u&quot; &quot;z&quot; letters[rep(seq(from = 1, to = 26, by = 5), each = 5)] ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;p&quot; &quot;p&quot; ## [18] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; 9.4.2 Estadísticas descriptivas En el conjunto de datos iris, ¿cuántos valores de ancho del sépalo son mayores que 3? Entre 2.8 y 3.2? ¿Cómo se puede visualizar la distribución de datos (función table())? ¿Cuáles son los 10 valores más pequeños? ¿Cómo se calcula el intervalo que contiene el 90% de los valores? Si la distribución de los datos era Normal, ¿cuál sería el valor teórico de este intervalo del 90% (función qnorm())? Soluciones: length(iris$Sepal.Width[iris$Sepal.Width &gt; 3]) ## [1] 67 length(iris$Sepal.Width[iris$Sepal.Width &gt; 2.8 &amp; iris$Sepal.Width &lt; 3.2]) ## [1] 47 table(iris$Sepal.Width) ## ## 2 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 ## 1 3 4 3 8 5 9 14 10 26 11 13 6 12 6 4 3 6 ## 3.9 4 4.1 4.2 4.4 ## 2 1 1 1 1 table(round(iris$Sepal.Width)) ## ## 2 3 4 ## 19 106 25 irisSepWCopy &lt;- iris$Sepal.Width irisSepWCopy &lt;- irisSepWCopy[order(irisSepWCopy)] head(irisSepWCopy, n = 10) ## [1] 2.0 2.2 2.2 2.2 2.3 2.3 2.3 2.3 2.4 2.4 quantile(irisSepWCopy, probs = c(0.05, 0.95)) ## 5% 95% ## 2.345 3.800 qnorm( p = c(0.05, 0.95), mean = mean(irisSepWCopy), sd = sd(irisSepWCopy) ) ## [1] 2.340397 3.774270 9.5 Escribir una función Cuando reproducimos las mismas operaciones varias veces, el código se vuelve difícil de escribir y de mantener porque si tenemos que hacer una modificación, tendremos que repetirla cada vez que la usemos. Esto es un signo de la necesidad de usar una función. En el siguiente ejemplo, sera largo modificar el código si queremos agregar +45 en lugar de +20 para cada línea. 35 + 20 ## [1] 55 758 + 20 ## [1] 778 862 + 20 ## [1] 882 782 + 20 ## [1] 802 Como todas las funciones básicas de R, nuestras funciones tendrán un nombre y argumentos. Al igual que con los nombres de los objetos y los nombres de los archivos, es importante elegir bien el nombre de nuestra función (ver la sección sobre objetos). Para crear una función utilizaremos la función function() que toma como argumento los argumentos de nuestra función. La función devolverá el resultado deseado. Por defecto, el resultado devuelto es el último utilizado, pero es mejor usar la función return(). La siguiente función addX() toma como argumento x y devuelve x + 20. addX &lt;- function(x){ return(x + 20) } Nuestro código se convierte en: addX(35) ## [1] 55 addX(758) ## [1] 778 addX(862) ## [1] 882 addX(782) ## [1] 802 Si queremos cambiar el código para agregar 45 en lugar de 20, simplemente cambiamos la función addX(). addX &lt;- function(x){ return(x + 45) } addX(35) ## [1] 80 addX(758) ## [1] 803 addX(862) ## [1] 907 addX(782) ## [1] 827 Aquí podríamos haber usado el formato vector para evitar la repetición, pero eso no siempre es posible. c(35, 758, 862, 782) + 20 ## [1] 55 778 882 802 Vamos a esribir una nueva función que contará el número de consonantes y vocales en minúsculas en una palabra. Primero separaremos todas las letras de la palabra con la función strsplit (podemos consultar la ayuda para saber más acerca de esta función). Luego contaremos las vocales y las consonantes con la función length(). Para la lista de letras, usaremos el objeto letters incluido en R que contiene las 26 letras en minuscula (consulte la ayuda con ?letters). print(letters) # las 26 letras ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; countVowelConso &lt;- function(word){ # nombre: countVowelConso ; argumento: word wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] # separar letras de word vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) # las vocales numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) # numero de vocales consonants &lt;- letters[!letters %in% vowels] # las consonantes numConso &lt;- length(wordSplit[wordSplit %in% consonants]) # numero de consonantes return(c(numVowel, numConso)) # el resultado de la funcion } Ahora podemos usar nuestra función. countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 Esta función se puede modificar mostrando un mensaje más explícito. Aunque en general se debe evitar este tipo de mensaje para evitar sobrecargar las funciones, puede ser útil verificar que todo esté funcionando correctamente (luego lo borraremos). countVowelConso &lt;- function(word){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- length(wordSplit[wordSplit %in% consonants]) print(paste0(&quot;Hay &quot;, numVowel, &quot; vocales y &quot;, numConso, &quot; consonantes en la palabra &#39;&quot;, word, &quot;&#39;.&quot;)) return(c(numVowel, numConso)) } countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] &quot;Hay 11 vocales y 9 consonantes en la palabra &#39;qwertyuiop azertyuiop&#39;.&quot; ## [1] 11 9 Por otro lado, si usamos countVowelConso(word = 5), se devolverá un error porque nuestra función espera un objeto de tipo character. En general, se recomienda manejar los errores devueltos por nuestras funciones para que nuestro código sea más fácil de mantener. Aquí simplemente comprobaremos que el argumento sea de tipo character, en un vector de tamaño 1. También comentaremos nuestra función para encontrar rápidamente lo que hace (comentario insertado en la primera línea, que a veces encontramos en la última línea de las funciones). countVowelConso &lt;- function(word){ # número de vocales y consonantes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- length(wordSplit[wordSplit %in% consonants]) return(c(numVowel, numConso)) } else { print(paste0(&quot;Error: &quot;, &quot;argumento &#39;word&#39; incorrecto (&quot;, word, &quot;)&quot;)) } } countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 countVowelConso(word = 5) ## [1] &quot;Error: argumento &#39;word&#39; incorrecto (5)&quot; Con R como para cualquier lenguaje de programación, para un problema siempre hay múltiples soluciones. Recordamos la sección sobre tipos de datos (tipo de datos logical), así como la sección sobre operadores de comparación que el valor de TRUE es 1 y el valor de FALSE es 0. Hemos visto anteriormente que la función % in% devuelve TRUE o FALSE para cada elemento del primer objeto dependiendo de su presencia o ausencia en el segundo objeto. Nuestra función podría haber usado otra función en lugar de length() para contar vocales y consonantes (función sum()). countVowelConsoAlt &lt;- function(word){ # número de vocales y consonantes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- sum(wordSplit %in% vowels) # &lt;- cambio aqui consonants &lt;- letters[!letters %in% vowels] numConso &lt;- sum(wordSplit %in% consonants) # &lt;- cambio aqui return(c(numVowel, numConso)) } else { print(paste0(&quot;Error: &quot;, &quot;argumento &#39;word&#39; incorrecto (&quot;, word, &quot;)&quot;)) } } countVowelConsoAlt(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 No existe una solución óptima en absoluto, todo depende de los objetivos deseados. La primera solución puede ser más fácil de entender, y la segunda puede ser más rápida en términos de velocidad de ejecución (repitiendo el uso de la función 10000 veces, el ahorro de tiempo es casi cero en nuestro caso). system.time(replicate(n = 10000, countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;))) ## user system elapsed ## 0.11 0.00 0.11 system.time(replicate(n = 10000, countVowelConsoAlt(word = &quot;qwertyuiop azertyuiop&quot;))) ## user system elapsed ## 0.11 0.00 0.11 Una función puede tener valores predeterminados para sus argumentos. Este es el caso para la mayoría de las funciones existentes. Por defecto, nuestra función ahora contará el número de vocales y consonantes en la palabra qwerty (los paréntesis son necesarios incluso en ausencia de argumentos). countVowelConsoAlt &lt;- function(word = &quot;qwerty&quot;){ # número de vocales y consonantes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- sum(wordSplit %in% vowels) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- sum(wordSplit %in% consonants) return(c(numVowel, numConso)) } else { print(paste0(&quot;Error: &quot;, &quot;argumento &#39;word&#39; incorrecto (&quot;, word, &quot;)&quot;)) } } countVowelConsoAlt() # no hay que olvidar los paréntesis ## [1] 2 4 R tiene muchas funciones, por lo tanto, antes de comenzar a escribir una nueva función, siempre debemos verificar que ya no exista en la versión básica de R o en los packages desarrollado por la comunidad de usuarios. Para esto podemos usar la ayuda con la función ??miBusqueda, pero también nuestro navegador de Internet. 9.6 Otras funciones desarrolladas por la comunidad de usuarios: los packages Un package (o paquete) es un conjunto de archivos que agregaremos a R para usar funciones (o conjuntos de datos) que otras personas hayan desarrollado. Actualmente hay más de 10,000 paquetes en los servidores CRAN de R (CRAN; https://cran.r-project.org/web/packages/), más de 1000 en los servidores de BioConductor (para análisis genómicos) y varios cientos en GitHub. Cada paquete hace posible usar nuevas funciones para casi todo … Por lo tanto, puede ser difícil encontrar el paquete adecuado para lo que queremos lograr, y es importante dedicar tiempo a la busqueda del paquete adecuado y probar varios soluciones. Para usar un paquete, primero debemos instalarlo, y luego cargarlo en nuestra sesión R. 9.6.1 Instalar un paquete Una vez que hemos seleccionado nuestro paquete, podemos descargarlo e instalarlo con la función install.packages(), que toma el nombre del paquete entre comillas como argumento (la función tolera la ausencia de comillas, pero es mejor usarlas para que el código sea más legible). Algunos paquetes ya son instalados por defecto con R, como stats (que también se carga de forma predeterminada). install.packages(&quot;stats&quot;) # R statistical functions La instalación de un paquete debe hacerse una vez, luego el paquete está en nuestra computadora. 9.6.2 Cargar un paquete Para poder usar las funciones de un paquete, tenemos que cargarlo en nuestra sesión R. Hay tantos paquetes disponibles que R no cargará todos los que tenemos instalados por defecto, sino solo los que necesitaremos para nuestro estudio actual. Para cargar un paquete usamos la función library() o require(). library(&quot;stats&quot;) La carga del paquete debe hacerse cada vez que queremos ejecutar nuestro código, por lo tanto, es una parte integral de nuestro script. 9.6.3 Portabilidad del código Acabamos de ver que la instalación de un paquete solo se debe hacer una vez por computadora, y que la carga de un paquete se debe lograr para cada nueva sesión de R. Si uno cambia de computadora o si compartimos un script con colegas, puede haber errores de ejecución relacionados con la falta de instalación de un paquete. Para superar este problema, se recomienda utilizar una función que verifique si los paquetes necesarios para ejecutar un script están instalados; si es necesario, instálelos y luego cárguelos. Hay muchas funciones para hacer esto en Internet. La solución que proponemos aquí es una mezcla adaptada de diferentes fuentes. No es necesario comprender los detalles de este script por el momento, sino simplemente comprender lo que hace. Este es un ejemplo para el paquete stats y graphics, dos paquetes que ya estan presente con la versión básica de R, pero podemos tratar todos los paquetes disponibles en CRAN; la lista se puede encontrar aquí: https://cran.r-project.org/web/packages/available_packages_by_name.html. pkgCheck &lt;- function(packages){ for(x in packages){ try(if(!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)){ stop() } }) } } pkgCheck(c(&quot;stats&quot;, &quot;graphics&quot;)) Alternativamente, podemos usar la función .packages() para listar los paquetes disponibles en el CRAN en orden alfabético. head(.packages(all.available = TRUE), n = 30) ## [1] &quot;abind&quot; &quot;acepack&quot; &quot;actuar&quot; &quot;ade4&quot; &quot;adehabitat&quot; ## [6] &quot;agricolae&quot; &quot;AlgDesign&quot; &quot;alr4&quot; &quot;animation&quot; &quot;ape&quot; ## [11] &quot;arm&quot; &quot;arules&quot; &quot;arulesViz&quot; &quot;assertthat&quot; &quot;audio&quot; ## [16] &quot;babynames&quot; &quot;backports&quot; &quot;base64&quot; &quot;base64enc&quot; &quot;BDgraph&quot; ## [21] &quot;beanplot&quot; &quot;BH&quot; &quot;bibtex&quot; &quot;bindr&quot; &quot;bindrcpp&quot; ## [26] &quot;binom&quot; &quot;bitops&quot; &quot;biwavelet&quot; &quot;bold&quot; &quot;bookdown&quot; La función pkgCheck() asegura la portabilidad de nuestros scripts: funcionarán en todas las computadoras sin tener que realizar ningún cambio. Por lo tanto, nuestros scipts pueden adjuntarse, por ejemplo, a nuestros artículos científicos y así garantizar la reproducibilidad de nuestros resultados. 9.7 Conclusión Felicitaciones! Ahora sabemos reconocer y usar una función, sabemos cómo buscar ayuda para una función e incluso sabemos escribir nuestras propias funciones. También sabemos que hay muchas funciones desarrolladas por la comunidad de usuarios de R dentro de paquetes (packages) que sabemos cómo instalar y cargar, y asegurar la portabilidad de nuestros scripts de una computadora a otra (importante para la reproducibilidad de los resultados). El próximo capítulo se enfocará en leer y escribir archivos porque nuestros datos suelen estar en archivos de texto u hojas de cálculo. "],
["import.html", " 10 Importar y exportar datos 10.1 Leer datos de un archivo 10.2 Guardar datos para R 10.3 Exportar datos", " 10 Importar y exportar datos 10.1 Leer datos de un archivo XXX 10.2 Guardar datos para R save load 10.3 Exportar datos write XXX "],
["loops.html", " 11 Los bucles 11.1 ¿Por qué hacer bucles? 11.2 El bucle if 11.3 El bucle switch 11.4 El bucle for 11.5 El bucle while 11.6 repeat, next, break, stop 11.7 Los bucles de la familia apply", " 11 Los bucles 11.1 ¿Por qué hacer bucles? XXX algorítmico … 11.2 El bucle if XXX 11.3 El bucle switch XXX 11.4 El bucle for XXX 11.5 El bucle while XXX 11.6 repeat, next, break, stop XXX 11.7 Los bucles de la familia apply 11.7.1 apply XXX 11.7.2 sapply XXX 11.7.3 lapply XXX 11.7.4 tapply XXX 11.7.5 mapply XXX "],
["graph1.html", " 12 Gráficos simples 12.1 plot 12.2 hist 12.3 barplot 12.4 boxplot 12.5 image y contour", " 12 Gráficos simples 12.1 plot 12.2 hist 12.3 barplot 12.4 boxplot 12.5 image y contour "],
["graph2.html", " 13 Gestión del color 13.1 colors() 13.2 RGB 13.3 Paletas", " 13 Gestión del color 13.1 colors() 13.2 RGB 13.3 Paletas "],
["graph3.html", " 14 Gráficos compuestos 14.1 mfrow 14.2 layout", " 14 Gráficos compuestos 14.1 mfrow 14.2 layout "],
["graph4.html", " 15 Manipular gráficos 15.1 Inkscape 15.2 The Gimp", " 15 Manipular gráficos 15.1 Inkscape 15.2 The Gimp "],
["stats1.html", " 16 Estadísticas descriptivas", " 16 Estadísticas descriptivas "],
["studyCase1.html", " 17 Analizar datos de loggers de temperatura", " 17 Analizar datos de loggers de temperatura "]
]
