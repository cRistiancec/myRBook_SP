# Contenedores de datos {#dataType2}

Hasta ahora hemos creado objetos simples que contienen solo un valor. Sin embargo, pudimos ver que un objeto tenía atributos diferentes, como su valor, pero también el tipo de datos contenidos (e.g., `numeric`, `character`). Ahora vamos a ver que hay diferentes tipos de contenedores para almacenar datos múltiples.

## El contenedor `vector`

En R, un `vector` es una combinación de datos con la particularidad de que todos los datos contenidos en un `vector` son del mismo tipo. Podemos almacenar por ejemplo múltiples elementos del tipo `character` o `numeric` en un `vector`, pero no ambos. El contenedor `vector` es importante porque es el elemento básico de R. 

### Crear un `vector`

Para crear un `vector` utilizaremos la función `c()` que permite combinar elementos en un `vector`. Los elementos para combinar deben estar separados por comas.

```{r}
miVec01 <- c(1, 2, 3, 4) # un vector de 4 elementos de tipo numeric ; double
print(miVec01)
typeof(miVec01)
is.vector(miVec01)
```

La funcion `is.vector()` permite verificar el tipo de contenedor.

```{r}
miVec02 <- c("a", "b", "c") 
print(miVec02)
typeof(miVec02)
is.vector(miVec02)

miVec03 <- c(TRUE, FALSE, FALSE, TRUE)
print(miVec03)
typeof(miVec03)
is.vector(miVec03)

miVecNA <- c(1, NA, 3, NA, 5)
print(miVecNA)
typeof(miVecNA)
is.vector(miVecNA)

miVec04 <- c(1, "a")
print(miVec04)
typeof(miVec04)
is.vector(miVec04)
```

Si combinamos diferentes tipos de datos, R intentará transformar los elementos en un tipo de forma predeterminada. Si como aquí en el objeto `miVec03` tenemos los tipos `character` y `numeric`, R convertirá todos los elementos en `character`.

```{r}
miVec05 <- c(factor("abc"), "def")
print(miVec05)
typeof(miVec05)
miVec06 <- c(TRUE, "def")
print(miVec06)
typeof(miVec06)
miVec07 <- c(factor("abc"), 55)
print(miVec07)
typeof(miVec07)
miVec08 <- c(TRUE, 55)
print(miVec08)
typeof(miVec08)
```

También podemos combinar objetos existentes dentro de un `vector`.

```{r}
miVec09 <- c(miVec02, "d", "e", "f")
print(miVec09)
miVec10 <- c("aaa", "aa", miVec09, "d", "e", "f")
print(miVec10)
miVec11 <- c(789, miVec01 , 564)
print(miVec11)
```

### Hacer operaciones con un `vector`

También podemos realizar operaciones en un `vector`.

```{r}
print(miVec01)
miVec01 + 1
miVec01 - 1
miVec01 * 2
miVec01 /10
```

Las operaciones de un `vector` a otro también son posibles, pero se debe tener cuidado para asegurar que el número de elementos en un `vector` sea el mismo que el otro, de lo contrario R realizará el cálculo comenzando desde el inicio del `vector` mas pequeño. Aquí hay un ejemplo para ilustrar lo que R hace:

```{r}
miVec12 <- c(1, 1, 1, 1, 1, 1, 1, 1, 1)
print(miVec12)
miVec13 <- c(10, 20, 30)
print(miVec13)
miVec12 + miVec13 # vectores de diferentes tamaños: atención al resultado
miVec14 <- c(10, 20, 30, 40, 50, 60, 70, 80, 90)
print(miVec14)
miVec12 + miVec14 # los vectores tienen el mismo tamaño
miVec15 <- c(1, 1, 1, 1)
print(miVec15)
miVec15 + miVec13 # vectores de diferentes tamaños y no múltiples
```

### Acceder a los valores de un `vector`

Suele pasar que sea necesario poder acceder a los valores de un `vector`, es decir, recuperar un valor o un grupo de valores dentro de un `vector`. Para acceder a un elemento de un `vector` usamos los corchetes `[]`. Entre los corchetes, podemos usar un número correspondiente al número del elemento en el `vector`.

```{r}
miVec20 <- c(10, 20, 30, 40, 50, 60, 70, 80, 90)
miVec21 <- c("a", "b", "c", "d", "e", "f", "g", "h", "i")
print(miVec20)
print(miVec21)

print(miVec20[1])
print(miVec21[3])
```

También podemos usar la combinación de diferentes elementos (otro `vector`).

```{r}
print(miVec20[c(1, 5, 9)])
print(miVec21[c(4, 3, 1)])
print(miVec21[c(4, 4, 3, 4, 3, 2, 5)])
```

También podemos seleccionar elementos usando un operador de comparación o un operador lógico.

```{r}
print(miVec20[miVec20 >= 50])
print(miVec20[(miVec20 >= 50) & ((miVec20 < 80))])
print(miVec20[miVec20 != 50])
print(miVec20[miVec20 == 30])
print(miVec20[(miVec20 == 30) | (miVec20 == 50)])

print(miVec21[miVec21 == "a"])
```

Otra característica interesante es la posibilidad de condicionar los elementos a seleccionar en base a otro `vector`.

```{r}
print(miVec21[miVec20 >= 50])
print(miVec21[(miVec20 >= 50) & ((miVec20 < 80))])
print(miVec21[miVec20 != 50])
print(miVec21[miVec20 == 30])
print(miVec21[(miVec20 == 30) | (miVec20 == 50)])
print(miVec21[(miVec20 == 30) | (miVec21 == "h")])
```

También es posible excluir ciertos elementos en lugar de seleccionarlos.

```{r}
print(miVec20[-1])
print(miVec21[-5])
print(miVec20[-c(1, 2, 5)])
print(miVec21[-c(1, 2, 5)])
```

Los elementos de un `vector` también se pueden seleccionar sobre la base de un `vector` tipo `logical`. En este caso, solo se seleccionarán elementos con un valor `TRUE`.

```{r}
miVec22 <- c(TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE)
print(miVec21[miVec22])
```

### Dar nombres a los elementos de un `vector`

Los elementos de un `vector` se pueden nombrar para referenciarlos y luego selectionarlos. La función `names()` recupera los nombres de los elementos de un vector.

```{r}
miVec23 <- c(aaa = 10, bbb = 20, ccc = 30, ddd = 40, eee = 50)
print(miVec23)
print(miVec23["bbb"])
print(miVec23[c("bbb", "ccc", "bbb")])
names(miVec23)
```

### Editar los elementos de un `vector`

Para modificar un `vector`, operamos de la misma manera que para modificar un objeto simple, con el signo `<-` y el elemento o los elementos a modificar entre corchetes.

```{r}
print(miVec21)
miVec21[3] <- "zzz"
print(miVec21)
miVec21[(miVec20 >= 50) & ((miVec20 < 80))] <- "qwerty"
print(miVec21)

print(miVec23)
miVec23["ccc"] <- miVec23["ccc"] + 100
print(miVec23)
```

También podemos cambiar los nombres asociados con los elementos de un `vector`.

```{r}
print(miVec23)
names(miVec23)[2] <- "bb_bb"
print(miVec23)
```

Podemos hacer mucho más con un `vector` y volveremos a su manejo y operaciones posibles en el capítulo sobre funciones.

## El contenedor `list`

El segundo tipo de contenedor que vamos a presentar es el contenedor `list`, que es también el segundo contenedor después del tipo` vector` debido a su importancia en la programación con R. El contenedor de tipo `list` le permite almacenar **listas** de elementos. Contrariamente a lo que vimos antes con el tipo `vector`, los elementos del tipo `list` pueden ser diferentes (por ejemplo, un `vector` de tipo `numeric`, luego un `vector` de tipo `character`). Los elementos del tipo `list` también pueden ser contenedores diferentes (por ejemplo, un `vector`, luego una `list`). El tipo de contenedor `list` tendrá mas sentido cuando hayamos estudiado los **bucles** y **funciones** de la familia `apply`.

### Crear una `list`

Para crear una `list` usaremos la función `list()`, que toma elementos (objetos) como argumentos.

```{r}
miList01 <- list()
print(miList01)
miList02 <- list(5, "qwerty", c(4, 5, 6), c("a", "b", "c"))
print(miList02)
miList03 <- list(5, "qwerty", list(c(4, 5, 6), c("a", "b", "c")))
print(miList03)
```

La función `is.list()` se usa para probar si hemos creado un objeto de tipo `list`.

```{r}
is.list(miList02)
typeof(miList02)
```

### Acceder a los valores de una `list`

Los elementos del contenedor `list` son identificables por los corchetes dobles `[[ ]]`. 

```{r}
print(miList02)
```

En el objeto de tipo `list` `miList02`, hay cuatro elementos identificables con `[[1]]`, `[[2]]`, `[[3]]` y `[[4]]`. Cada uno de los elementos es de tipo `vector`.  El primer elemento tiene un tamaño de 1 con elementos del tipo `double`, el segundo elemento tiene un tamaño de 1 con elementos del tipo `character`, el tercero elemento tiene un tamaño de 3 con elementos del tipo `double`, y el cuarto elemento tiene un tamaño de 3 con elementos del tipo `character`.

```{r}
typeof(miList02)
print(miList02[[1]])
typeof(miList02[[1]])
print(miList02[[2]])
typeof(miList02[[2]])
print(miList02[[3]])
typeof(miList02[[3]])
print(miList02[[4]])
typeof(miList02[[4]])
```

El acceso al segundo elemento del `vector` ubicado en la cuarta posición de la `list` se hace con `miList02[[4]][2]`. Usamos doble corchetes para el cuarto elemento de la `list`, luego corchetes simples para el segundo elemento del `vector`.

```{r}
print(miList02[[4]][2])
```

Como una `list` puede contener una o más `list`, podemos acceder a la información buscada combinando corchetes dobles. El objeto `miList04` es una `list` de dos elementos: la `list` `miList02` y la `list` `miList03`. El objeto `miList03` en sí contiene una `list` como tercer elemento. Para acceder al primer elemento del `vector` en la primera posición del elemento en la tercera posición del segundo elemento del `list` `miList04`, podemos usar `miList04[[2]][[3]][[1]][1]`. No hay límite en cuanto a la profundidad de `list` pero en la práctica raramente hay necesidad de hacer `list` de `list` de `list`.

```{r}
miList04 <- list(miList02, miList03)
print(miList04)
print(miList04[[2]][[3]][[1]][1])
```

Para concretar el ejemplo anterior, podemos imaginar especies de barrenadores del maíz (*Sesamia nonagrioides* y *Ostrinia nubilalis*), muestreados en diferentes sitios, con diferentes abundancias en cuatro fechas. Aquí daremos nombres a los elementos de las `list`.

```{r}
bddInsect <- list(Snonagrioides = list(site01 = c(12, 5, 8, 7), site02 = c(5, 23, 4, 41), site03 = c(12, 0, 0, 0)), Onubilalis = list(site01 = c(12, 1, 2, 3), site02 = c(0, 0, 0, 1), site03 = c(1, 1, 2, 3)))
print(bddInsect)
```

```{block, type='rmdstyle'}
Leer una larga línea de código como la línea para crear el objeto `bddInsect` resulta difícil porque la profundidad de los elementos solo se puede deducir de los paréntesis. Es por eso que vamos a reorganizar el código para que sea más legible mediante el **margen adicional**. El margen adicional implica poner información en diferentes niveles para que podamos identificar rápidamente los diferentes niveles de un código. Para aplicar el margen adicional se presiona la tecla de tabulación. Volveremos al margen adicional con más detalles en el capítulo sobre **bucles**. Recordemos por el momento que si una línea de código es demasiado larga, podemos saltar de línea y usar el margen adicional. R leerá todo como una sola línea de código.
```

```{r}
bddInsect <- list(
  Snonagrioides = list(
    site01 = c(12, 5, 8, 7), 
    site02 = c(5, 23, 4, 41), 
    site03 = c(12, 0, 0, 0)
  ), 
  Onubilalis = list(
    site01 = c(12, 1, 2, 3), 
    site02 = c(0, 0, 0, 1), 
    site03 = c(1, 1, 2, 3)
  )
)
```

Podemos seleccionar los datos de abundancia del segundo sitio de la primera especie como previamente `bddInsect[[1]][[2]]`, o alternativamente usando los nombres de los elementos `bddInsect$Snonagrioides$site02`. Para hacer esto usamos el signo `$`, o como alternativa el nombre de los elementos con comillas simples o dobles `bddInsect[['Snonagrioides']][['sitio02']]`.

```{r}
print(bddInsect[[1]][[2]])
print(bddInsect$Snonagrioides$site02)
print(bddInsect[['Snonagrioides']][['site02']])
```

En cuanto a los vectores, podemos recuperar los nombres de los elementos con la función `names()`.

```{r}
names(bddInsect)
names(bddInsect[[1]])
```

Cuando usamos los corchetes dobles `[[]]` o el signo `$`, R devuelve el contenido del elemento seleccionado. En nuestro ejemplo, los datos de abundancia están contenidos como un `vector`, por lo que R devuelve un elemento del tipo `vector`. Si queremos seleccionar un elemento de una `list` pero manteniendo el formato `list`, entonces podemos usar corchetes simples `[]`.

```{r}
print(bddInsect[[1]][[2]])
typeof(bddInsect[[1]][[2]])
is.list(bddInsect[[1]][[2]])

print(bddInsect[[1]][2])
typeof(bddInsect[[1]][2])
is.list(bddInsect[[1]][2])
```

El uso de corchetes simples `[]` es útil cuando queremos recuperar varios elementos de una `list`. Por ejemplo, para seleccionar las abundancias de insectos de los primeros dos sitios de la primera especie, usaremos `bddInsect [[1]][c(1, 2)]` o alternativamente `bddInsect[[1]][c("site01", "sitio02")]`.

```{r}
print(bddInsect[[1]][c(1, 2)])
print(bddInsect[[1]][c("site01", "site02")])
```

### Editar una `list`

Una `list` se puede modificar de la misma manera que para el contenedor `vector`, es decir, haciendo referencia con corchetes al elemento que queremos modificar.

```{r}
print(miList02)
miList02[[1]] <- 12
print(miList02)
miList02[[4]] <- c("d", "e", "f")
print(miList02)
miList02[[4]] <- c("a", "b", "c", miList02[[4]], "g", "h", "i")
print(miList02)
miList02[[4]][5] <- "eee"
print(miList02)
miList02[[3]] <- miList02[[3]] * 10 - 1
print(miList02)
miList02[[3]][2] <- miList02[[1]] * 100
print(miList02)

print(bddInsect)
bddInsect[['Snonagrioides']][['site02']] <- c(2, 4, 6, 8)
print(bddInsect)
```

Para combinar dos `list`, simplemente usamos la función `c()` que hemos usado para crear un `vector`.

```{r}
miList0203 <- c(miList02, miList03)
print(miList0203)
```

Un objeto de tipo `list` se puede transformar en `vector` con la función `unlist()` si el formato de los elementos de la lista lo permite (un `vector` solo puede contener elementos del mismo tipo).

```{r}
miList05 <- list("a", c("b", "c"), "d")
print(miList05)
miVec24 <- unlist(miList05)
print(miVec24)
miList06 <- list(c(1, 2, 3), c(4, 5, 6, 7), 8, 9, c(10, 11))
print(miList06)
miVec25 <- unlist(miList06)
print(miVec25)
```

Para agregar un elemento a una `list`, podemos usar la función `c()` o los corchetes dobles `[[ ]]`.

```{r}
print(miList05)
miList05 <- c(miList05, "e")
print(miList05)
miList05[[5]] <- c("fgh", "ijk")
print(miList05)
```

Para eliminar un elemento de una `list`, la técnica más rápida es establecer `NULL` en el elemento que deseamos eliminar.

```{r}
print(miList05)
miList05[[2]] <- NULL
print(miList05)
```

## El contenedor `data.frame`

XXX

## El contenedor `matrix`

XXX

## El contenedor `array`

XXX
